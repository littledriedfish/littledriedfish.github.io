<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Webpack和Vite打包工具的具体工作流程以及区别</title>
    <link href="/2023/06/25/vite%20Webpack%E5%92%8CVite/"/>
    <url>/2023/06/25/vite%20Webpack%E5%92%8CVite/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack和vite工作流程图"><a href="#webpack和vite工作流程图" class="headerlink" title="webpack和vite工作流程图"></a>webpack和vite工作流程图</h1><h1 id="vite优点"><a href="#vite优点" class="headerlink" title="vite优点:"></a>vite优点:</h1><p>1.webpack服务器启动速度比vite慢<br>2.由于vite启动的时候不需要打包，也就无需分析模块依赖、编译，所以启动速度非常快。当浏览器请求需要的模块时，再对模块进行编译，这种按需动态编译的模式，极大缩短了编译时间，当项目越大，文件越多时，vite的开发时优势越明显<br>3.vite热更新比webpack快<br>4.vite在HRM方面，当某个模块内容改变时，让浏览器去重新请求该模块即可，而不是像webpack重新将该模块的所有依赖重新编译,<br>5.vite使用esbuild(Go 编) 预构建依赖，而webpack基于nodejs,比node快 10-100 倍</p><h1 id="vite缺点"><a href="#vite缺点" class="headerlink" title="vite缺点:"></a>vite缺点:</h1><p>1.生态不及webpack，加载器、插件不够主富<br>2.打包到生产环境时，vite使用传统的rolup进行打包，生产环境esbuild构建对于CSs和代码分割不够友好。所以，vite的优势是体现在开发阶段<br>没被大规模重度使用，会隐藏一些问题<br>项目的开发浏览器要支持esmodule，而目不能识别commonis语法<br>3.webpack和vite的工作流程及区别（通俗解释）<br>webpack和vite的工作流程：<br>webpack打包是先分析项目路由然后分析路由相对应的模块，然后全部打包，再调用服务器，所以编译速度较慢，没有用到的模块也全部打包了。<br>vite是先调用服务器，直接准备好，然后看你请求的是哪一个路由然后只去打包哪一个路由所对应的模块，没有请求的路由就不去打包，做到了按需编译打包，不再等待整个应用编译完成，提高了编译运行时速度。</p>]]></content>
    
    
    <categories>
      
      <category>Vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3 Composition API 和 Vue Mixins (1)</title>
    <link href="/2022/05/28/vue3%20Composition%20API%20%E5%92%8C%20Vue%20Mixins(1)/"/>
    <url>/2022/05/28/vue3%20Composition%20API%20%E5%92%8C%20Vue%20Mixins(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h2><p>Vue组件之间共享代码<br>熟悉Vue 2，你可能已经使用了一个 mixin 来实现这个目的。但是新的Composition API，现在作为Vue 2的插件和Vue 3即将推出的一项功能，提供了一个更好的解决方案。</p><p>在这篇文章中，我们将看看Mixins的缺点，并看看Composition API是如何克服这些缺点，让Vue应用的可扩展性更强。</p><h2 id="Mixins简述"><a href="#Mixins简述" class="headerlink" title="Mixins简述"></a>Mixins简述</h2><p>让我们快速回顾一下mixins模式。</p><p>通常情况下，一个Vue组件是由一个JavaScript对象来定义的，这个JavaScript对象具有各种属性，代表着我们需要的功能，data, methods, computed等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">// MyComponent.js<br><span class="hljs-built_in">export</span> default &#123;<br>    data: () =&gt; (&#123;<br>        myDataProperty: null<br>    &#125;),<br>    methods: &#123;<br>        <span class="hljs-function"><span class="hljs-title">myMethod</span></span> () &#123; ... &#125;<br>    &#125;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们想在组件之间共享相同的属性时，我们可以将共同的属性提取到一个单独的模块中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">// MyMixin.js<br><span class="hljs-built_in">export</span> default &#123;<br>  data: () =&gt; (&#123;<br>    mySharedDataProperty: null<br>  &#125;),<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">mySharedMethod</span></span> () &#123; ... &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以通过将其分配给mixin config属性并将其添加到任何使用的组件中。在运行时，Vue将把组件的属性与任何添加的mixin合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">// ConsumingComponent.js<br>import MyMixin from <span class="hljs-string">&quot;./MyMixin.js&quot;</span>;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  mixins: [MyMixin],<br>  data: () =&gt; (&#123;<br>    myLocalDataProperty: null<br>  &#125;),<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">myLocalMethod</span></span> () &#123; ... &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个具体的例子中，运行时使用的组件定义是这样的。 可以看出mixin的组件属性(data、mthods..)都会分别进入了引入页面的相对位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> default &#123;<br>  data: () =&gt; (&#123;<br>    mySharedDataProperty: null<br>    myLocalDataProperty: null<br>  &#125;),<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">mySharedMethod</span></span> () &#123; ... &#125;,<br>    <span class="hljs-function"><span class="hljs-title">myLocalMethod</span></span> () &#123; ... &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mixins的缺点"><a href="#Mixins的缺点" class="headerlink" title="Mixins的缺点"></a>Mixins的缺点</h2><p>不清晰的数据来源：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。<br>命名空间冲突：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。<br>隐式的跨 mixin 交流：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。</p><h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p>我们看到mixin模式是如何在运行时合并两个对象的。如果它们都共享一个同名的属性，会发生什么？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">const mixin = &#123;<br>  data: () =&gt; (&#123;<br>    myProp: null<br>  &#125;)<br>&#125;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  mixins: [mixin],<br>  data: () =&gt; (&#123;<br>    // same name!<br>    myProp: null<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是合并策略发挥作用的地方。这是一组规则，用于决定当一个组件包含多个相同名称的选项时的情况。</p><p>Vue 组件的默认（但可选择配置）合并策略决定了本地选项将覆盖混合器选项。但也有例外。例如，如果我们有多个相同类型的生命周期钩子，那么这些钩子将被添加到钩子数组中，并且所有的钩子将被依次调用。</p><p>尽管我们不应该遇到任何实际的错误，但当我们在多个组件和混合体之间杂耍命名的属性时，写代码会变得越来越困难。尤其是当第三方的混合组件被添加为npm包时，这就更难了，因为它们的命名属性可能会引起冲突。</p><p>mixins 的缺点促进了 Composition API。来看看Composition API 如何运行。</p><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><p>组合式API的关键思想是，我们将组件的功能（如状态、方法、计算属性等）定义为对象属性，而不是将其定义为从新的设置函数中返回的JavaScript变量。</p><p>以这个经典的Vue 2组件为例，它定义了一个 “计数器 “功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">//Counter.vue<br><span class="hljs-built_in">export</span> default &#123;<br>  data: () =&gt; (&#123;<br>    count: 0<br>  &#125;),<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span></span>() &#123;<br>      this.count++;<br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">double</span></span> () &#123;<br>      <span class="hljs-built_in">return</span> this.count * 2;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是使用 Composition API 定义的完全相同的组件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">// Counter.vue<br>import &#123; ref, computed &#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span></span>() &#123;<br>    const count = ref(0);<br>    const double = computed(() =&gt; count * <span class="hljs-number">2</span>)<br>    function increment() &#123;<br>      count.value++;<br>    &#125;<br>    return &#123;<br>      count,<br>      double,<br>      increment<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先你会注意到我们导入了一个ref函数，这使得我们可以定义一个响应式变量，其功能与数据变量基本相同。计算函数也是一样的。</p><p>增量方法不是响应式的，所以它可以被声明为一个普通的JavaScript函数。注意，我们需要改变子属性值，才能改变count响应式变量的值。这是因为使用 ref 创建的响应式变量在传递过程中，需要将其作为对象来保留响应式变量。</p><p>一旦我们定义了这些功能，我们就从setup函数中返回这些功能。上面的两个组件在功能上没有什么区别。我们所做的就是使用替代API。</p><p class="note note-primary">Composition API将是Vue 3的核心功能，但你也可以在Vue 2中通过NPM插件@vue/composition-api使用它。</p><p>&#x2F;&#x2F;useCounter.js<br>import { ref, computed } from “vue”;</p><p>功能代码提取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> default <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>  const count = ref(0);<br>  const double = computed(() =&gt; count * <span class="hljs-number">2</span>)<br>  function increment() &#123;<br>    count.value++;<br>  &#125;<br>  return &#123;<br>    count,<br>    double,<br>    increment<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>功能代码重用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// MyComponent.js<br>import useCounter from <span class="hljs-string">&quot;./useCounter.js&quot;</span>;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span></span>() &#123;<br>    const &#123; count, double, increment &#125; = useCounter();<br>    <span class="hljs-built_in">return</span> &#123;<br>      count,<br>      double,<br>      increment<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Composition-API优点"><a href="#Composition-API优点" class="headerlink" title="Composition API优点"></a>Composition API优点</h2><p>响应式 API：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。<br>生命周期钩子：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。<br>依赖注入：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>mixin模式表面上看起来很安全。然而，通过合并对象来共享代码，由于它给代码增加了脆弱性，并且掩盖了推理功能的能力，因此成为一种反模式。</p><p>Composition API 最聪明的地方在于，它允许 Vue 依靠原生 JavaScript 内置的保障措施来共享代码，比如将变量传递给函数，以及模块系统。</p><p>这是否意味着Composition API在各方面都比Vue的经典API优越？不是的，在大多数情况下，你可以坚持使用经典的API。但是，如果你打算重用代码，Composition API无疑是优越的。</p><p>本文参考: <a href="https://css-tricks.com/how-the-Vue-composition-api-replaces-vue-mixins/">https://css-tricks.com/how-the-Vue-composition-api-replaces-vue-mixins/</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
      <category>Composition API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3 基础使用</title>
    <link href="/2022/04/22/vue3%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/22/vue3%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3简介"><a href="#Vue3简介" class="headerlink" title="Vue3简介"></a>Vue3简介</h1><p>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）<br>github上的tags地址：<a href="https://github.com/vuejs/core/releases/tag/v3.0.0">Release v3.0.0 One Piece · vuejs&#x2F;core · GitHub</a></p><h1 id="Vue3优势"><a href="#Vue3优势" class="headerlink" title="Vue3优势"></a>Vue3优势</h1><h2 id="性能的提升"><a href="#性能的提升" class="headerlink" title="性能的提升"></a>性能的提升</h2><p>打包大小减少41%<br>初次渲染快55%, 更新渲染快133%<br>内存减少54%</p><h2 id="性能的提升-1"><a href="#性能的提升-1" class="headerlink" title="性能的提升"></a>性能的提升</h2><p>源码的升级<br>使用Proxy代替defineProperty实现响应式<br>重写虚拟DOM的实现和Tree-Shaking</p><h2 id="拥抱TypeScript"><a href="#拥抱TypeScript" class="headerlink" title="拥抱TypeScript"></a>拥抱TypeScript</h2><p>Vue3可以更好的支持TypeScript</p><h2 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h2><p>Composition API（组合API）<br>setup配置<br>ref与reactive<br>watch与watchEffect<br>provide与inject<br>……</p><h2 id="新的内置组件"><a href="#新的内置组件" class="headerlink" title="新的内置组件"></a>新的内置组件</h2><p>Fragment<br>Teleport<br>Suspense</p><h2 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h2><p>新的生命周期钩子<br>data 选项应始终被声明为一个函数<br>移除keyCode支持作为 v-on 的修饰符</p><h1 id="创建Vue3-0工程"><a href="#创建Vue3-0工程" class="headerlink" title="创建Vue3.0工程"></a>创建Vue3.0工程</h1><h2 id="使用-vue-cli-创建"><a href="#使用-vue-cli-创建" class="headerlink" title="使用 vue-cli 创建"></a>使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">创建一个项目 | Vue CLI</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span><br>vue --version<br><span class="hljs-comment">## 安装或者升级你的@vue/cli</span><br>npm install -g @vue/cli<br><span class="hljs-comment">## 创建</span><br>vue create vue_test<br><span class="hljs-comment">## 启动</span><br><span class="hljs-built_in">cd</span> vue_test<br>npm run serve<br></code></pre></td></tr></table></figure><h2 id="使用-vite-创建"><a href="#使用-vite-创建" class="headerlink" title="使用 vite 创建"></a>使用 vite 创建</h2><p>官方文档：<a href="https://cn.vuejs.org/guide/quick-start.html#vite">快速上手 | Vue.js</a><br>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a><br>什么是vite？—— 新一代前端构建工具。</p><p>优势如下：<br>    <ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li><li>传统构建 与 vite构建对比图</li></ul></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建工程</span><br>npm init vite-app &lt;project-name&gt;<br><span class="hljs-comment">## 进入工程目录</span><br><span class="hljs-built_in">cd</span> &lt;project-name&gt;<br><span class="hljs-comment">## 安装依赖</span><br>npm install<br><span class="hljs-comment">## 运行</span><br>npm run dev<br></code></pre></td></tr></table></figure><h2 id="常用-Composition-API"><a href="#常用-Composition-API" class="headerlink" title="常用 Composition API"></a>常用 Composition API</h2><p>官方文档: <a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html">组合式 API 常见问答 | Vue.js</a><br><a href="/2022/05/28/vue3%20Composition%20API%20%E5%92%8C%20Vue%20Mixins(1)/">Composition API 和 mixins 可移步</a></p><h3 id="1-setup"><a href="#1-setup" class="headerlink" title="1.setup"></a>1.setup</h3><p>理解：Vue3.0中一个新的配置项，值为一个函数。<br>setup是所有Composition API（组合API）“ 表演的舞台 ”。<br>组件中所用到的：数据、方法等等，均要配置在setup中。<br>setup函数的两种返回值：<br>&emsp;&emsp;若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）<br>&emsp;&emsp;若返回一个渲染函数：则可以自定义渲染内容。（了解）<br>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</p><p class="note note-warning">注意：尽量不要与Vue2.x配置混用，Vue2.x配置（data、methos、computed...）中可以访问到setup中的属性、方法。但在setup中不能访问到Vue2.x配置（data、methos、computed...）。如果有重名, setup优先。</p><h3 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h3><p>作用: 定义一个响应式的数据<br>语法: const xxx &#x3D; ref(initValue)</p><p>创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。<br>JS中操作数据： xxx.value<br>模板中读取数据: 不需要.value，直接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p class="note note-success">备注：接收的数据可以是：基本类型、也可以是对象类型。基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。</p><h3 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h3><p>作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）<br>语法：const 代理对象&#x3D; reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）</p><p>reactive定义的响应式数据是“深层次的”。<br>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</p><h3 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h3><h4 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h4><p>实现原理：<br>&emsp;&emsp;对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。<br>&emsp;&emsp;数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Object.defineProperty(data, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span></span> () &#123;&#125;, <br>    <span class="hljs-function"><span class="hljs-title">set</span></span> () &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>存在问题：<br>&emsp;&emsp;新增属性、删除属性, 界面不会更新。<br>&emsp;&emsp;直接通过下标修改数组, 界面不会自动更新。</p><h4 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h4><p>实现原理:<br>&emsp;&emsp;通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。<br>&emsp;&emsp;通过Reflect（反射）: 对源对象的属性进行操作。</p><p>MDN文档中描述的Proxy与Reflect：<br>&emsp;&emsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy：Proxy - JavaScript | MDN</a><br>&emsp;&emsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect：Reflect - JavaScript | MDN</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">new Proxy(data, &#123;<br>    // 拦截读取属性值<br>    get (target, prop) &#123;<br>        <span class="hljs-built_in">return</span> Reflect.get(target, prop)<br>    &#125;,<br>    // 拦截设置属性值或添加新属性<br>    <span class="hljs-built_in">set</span> (target, prop, value) &#123;<br>        <span class="hljs-built_in">return</span> Reflect.<span class="hljs-built_in">set</span>(target, prop, value)<br>    &#125;,<br>    // 拦截删除属性<br>    deleteProperty (target, prop) &#123;<br>        <span class="hljs-built_in">return</span> Reflect.deleteProperty(target, prop)<br>    &#125;<br>&#125;)<br>proxy.name = <span class="hljs-string">&#x27;tom&#x27;</span> <br></code></pre></td></tr></table></figure><h3 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h3><p>从定义数据角度对比：<br>&emsp;&emsp;ref用来定义：基本类型数据。<br>&emsp;&emsp;reactive用来定义：对象（或数组）类型数据。</p><p class="note note-success">备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。</p><p>从原理角度对比：<br>&emsp;&emsp;ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。<br>&emsp;&emsp;reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。</p><p>从使用角度对比：<br>&emsp;&emsp;ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。<br>&emsp;&emsp;reactive定义的数据：操作数据与读取数据：均不需要.value。</p><h3 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h3><p>setup执行的时机<br>&emsp;&emsp;在beforeCreate之前执行一次，this是undefined。<br>setup的参数<br>&emsp;&emsp;props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。<br>&emsp;&emsp;context：上下文对象<br>&emsp;&emsp;attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。<br>&emsp;&emsp;slots: 收到的插槽内容, 相当于 this.$slots。<br>&emsp;&emsp;emit: 分发自定义事件的函数, 相当于 this.$emit。</p><h3 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h3><h4 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h4><p>与Vue2.x中computed配置功能一致<br>写法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">import &#123;computed&#125; from <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-function"><span class="hljs-title">setup</span></span>()&#123;<br>    ...<br>    //计算属性——简写<br>    <span class="hljs-built_in">let</span> fullName = computed(()=&gt;&#123;<br>        return person.firstName + &#x27;-&#x27; + person.lastName<br>    &#125;)<br>    //计算属性——完整<br>    let fullName = computed(&#123;<br>        get()&#123;<br>            return person.firstName + &#x27;-&#x27; + person.lastName<br>        &#125;,<br>        set(value)&#123;<br>            const nameArr = value.split(&#x27;-&#x27;)<br>            person.firstName = nameArr[<span class="hljs-number">0</span>]<br>            person.lastName = nameArr[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h4><p>与Vue2.x中watch配置功能一致</p><p class="note note-primary">两个小“坑”：监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。监视reactive定义的响应式数据中某个属性时：deep配置有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">//情况一：监视ref定义的响应式数据<br>watch(<span class="hljs-built_in">sum</span>,(newValue,oldValue)=&gt;&#123;<br>    console.log(<span class="hljs-string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;immediate:<span class="hljs-literal">true</span>&#125;)<br>​<br>//情况二：监视多个ref定义的响应式数据<br>watch([<span class="hljs-built_in">sum</span>,msg],(newValue,oldValue)=&gt;&#123;<br>    console.log(<span class="hljs-string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)<br>&#125;) <br>​<br>/* 情况三：监视reactive定义的响应式数据<br>            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！<br>            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 <br>*/<br>watch(person,(newValue,oldValue)=&gt;&#123;<br>    console.log(<span class="hljs-string">&#x27;person变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;immediate:<span class="hljs-literal">true</span>,deep:<span class="hljs-literal">false</span>&#125;) //此处的deep配置不再奏效<br>​<br>//情况四：监视reactive定义的响应式数据中的某个属性<br>watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:true&#125;) <br>​<br>//情况五：监视reactive定义的响应式数据中的某些属性<br>watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:true&#125;)<br>​<br>//特殊情况<br>watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效<br></code></pre></td></tr></table></figure><h4 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h4><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。<br>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p><p>watchEffect有点像computed：<br>&emsp;&emsp;但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。<br>&emsp;&emsp;而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。<br>watchEffect(()=&gt;&#123;<br>    const x1 = sum.value<br>    const x2 = person.age<br>    console.log(&#x27;watchEffect配置的回调执行了&#x27;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h3><h4 id="vue2-x的生命周期"><a href="#vue2-x的生命周期" class="headerlink" title="vue2.x的生命周期"></a>vue2.x的生命周期</h4><pre><code class="hljs">(略)</code></pre><h4 id="vue3-0的生命周期"><a href="#vue3-0的生命周期" class="headerlink" title="vue3.0的生命周期"></a>vue3.0的生命周期</h4><p>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<br>&emsp;&emsp;beforeDestroy改名为 beforeUnmount<br>&emsp;&emsp;destroyed改名为 unmounted</p><p>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</p><p>beforeCreate &#x3D;&#x3D;&#x3D;&gt; setup()<br>created &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; setup()<br>beforeMount &#x3D;&#x3D;&#x3D;&gt; onBeforeMount<br>mounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; onMounted<br>beforeUpdate &#x3D;&#x3D;&#x3D;&gt; onBeforeUpdate<br>updated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; onUpdated<br>beforeUnmount &#x3D;&#x3D;&gt; onBeforeUnmount<br>unmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; onUnmounted</p><h3 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h3><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p><p>类似于vue2.x中的mixin。<a href="/2022/05/28/vue3%20Composition%20API%20%E5%92%8C%20Vue%20Mixins(1)/">Composition API 和 mixins 可移步</a><br>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p><h3 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h3><p><a href="/2021/10/09/vue3%20%E5%9F%BA%E7%A1%80-toRef/">vue3 基础-toRef 可移步</a><br>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。<br>语法：const name &#x3D; toRef(person,’name’)<br>应用: 要将响应式对象中的某个属性单独提供给外部使用时。<br>扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)</p><h2 id="其它-Composition-API"><a href="#其它-Composition-API" class="headerlink" title="其它 Composition API"></a>其它 Composition API</h2><h3 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h3><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。<br>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p><p class="note note-primary">    什么时候使用?    如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowReactive。    如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===> shallowRef。</p><h3 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h3><p>readonly: 让一个响应式数据变为只读的（深只读）。<br>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</p><p class="note note-primary">    应用场景: 不希望数据被修改时。</p><h3 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h3><p>toRaw：<br>作用：将一个由reactive生成的响应式对象转为普通对象。</p><p class="note note-primary">    使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</p><p>markRaw：<br>作用：标记一个对象，使其永远不会再成为响应式对象。</p><p class="note note-primary">    应用场景:    有些值不应被设置为响应式的，例如复杂的第三方类库等。    当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</p><h3 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h3><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p><p>实现防抖效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>    &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;keyword&quot;</span>&gt;<br>    &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br>​<br>&lt;script&gt;<br>    import &#123;ref,customRef&#125; from <span class="hljs-string">&#x27;vue&#x27;</span><br>    <span class="hljs-built_in">export</span> default &#123;<br>        name:<span class="hljs-string">&#x27;Demo&#x27;</span>,<br>        <span class="hljs-function"><span class="hljs-title">setup</span></span>()&#123;<br>            // <span class="hljs-built_in">let</span> keyword = ref(<span class="hljs-string">&#x27;hello&#x27;</span>) //使用Vue准备好的内置ref<br>            //自定义一个myRef<br>            <span class="hljs-keyword">function</span> myRef(value,delay)&#123;<br>                <span class="hljs-built_in">let</span> timer<br>                //通过customRef去实现自定义<br>                <span class="hljs-built_in">return</span> customRef((track,trigger)=&gt;&#123;<br>                    return&#123;<br>                        get()&#123;<br>                            track() //告诉Vue这个value值是需要被“追踪”的<br>                            return value<br>                        &#125;,<br>                        set(newValue)&#123;<br>                            clearTimeout(timer)<br>                            timer = setTimeout(()=&gt;&#123;<br>                                value = newValue<br>                                trigger() //告诉Vue去更新界面<br>                            &#125;,delay)<br>                        &#125;<br>                    &#125;<br>                &#125;)<br>            &#125;<br>            let keyword = myRef(&#x27;hello&#x27;,<span class="hljs-number">500</span>) //使用自定义的ref<br>            return &#123;<br>                keyword<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h3><p>作用：实现祖与后代组件间通信<br>套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据</p><p>具体写法：</p><p>祖组件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">setup</span></span>()&#123;<br>    ......<br>    <span class="hljs-built_in">let</span> car = reactive(&#123;name:<span class="hljs-string">&#x27;奔驰&#x27;</span>,price:<span class="hljs-string">&#x27;40万&#x27;</span>&#125;)<br>    provide(<span class="hljs-string">&#x27;car&#x27;</span>,car)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>后代组件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">setup(props,context)&#123;<br>    ......<br>    const car = inject(<span class="hljs-string">&#x27;car&#x27;</span>)<br>    <span class="hljs-built_in">return</span> &#123;car&#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h3><p>isRef: 检查一个值是否为一个 ref 对象<br>isReactive: 检查一个对象是否是由 reactive 创建的响应式代理<br>isReadonly: 检查一个对象是否是由 readonly 创建的只读代理<br>isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</p><h1 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/images/composition1.gif" alt="图片" title=" "></div><div class="group-image-wrap"><img src="/images/composition2.gif" alt="图片" title=" "></div></div></div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/images/composition3.gif" alt="图片" title=" "></div><div class="group-image-wrap"><img src="/images/composition4.gif" alt="图片" title=" "></div></div></div><h1 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><p>在Vue2中: 组件必须有一个根标签<br>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中<br>好处: 减少标签层级, 减小内存占用</p><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><p>什么是Teleport？—— 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- <br>    to： body html  传送位置<br>    disabled： <span class="hljs-literal">true</span> 不传送 <span class="hljs-literal">false</span> 传送<br>--&gt;<br>&lt;teleport to=<span class="hljs-string">&quot;body&quot;</span> :disabled=<span class="hljs-string">&quot;false&quot;</span>&gt;<br>&lt;div v-if=<span class="hljs-string">&quot;isShow&quot;</span> class=<span class="hljs-string">&quot;mask&quot;</span>&gt;<br>&lt;div class=<span class="hljs-string">&quot;dialog&quot;</span>&gt;<br>&lt;h3&gt;我是一个弹窗&lt;/h3&gt;<br>&lt;button @click=<span class="hljs-string">&quot;isShow = false&quot;</span>&gt;关闭弹窗&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/teleport&gt;<br></code></pre></td></tr></table></figure><p>多个 &lt; Teleport &gt; 组件可以将其内容挂载在同一个目标元素上，而顺序就是简单的顺次追加，后挂载的将排在目标元素下更后面的位置上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- index.html --&gt;<br>&lt;body&gt;<br>  &lt;div <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;&lt;/div&gt;<br>  &lt;div <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;customDom&quot;</span>&gt;&lt;/div&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>  app组件<br>  &lt;Teleport to=<span class="hljs-string">&quot;#customDom&quot;</span>&gt;<br>    &lt;p&gt;我是被 teleport 包裹的一号元素&lt;/p&gt;<br>  &lt;/Teleport&gt;<br>  &lt;Teleport to=<span class="hljs-string">&quot;#customDom&quot;</span>&gt;<br>    &lt;p&gt;我是被 teleport 包裹的二号元素&lt;/p&gt;<br>  &lt;/Teleport&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p class="note note-primary">应用：当项目中多处使用多弹窗时候，避免层级不好控制（z-index）时使用，把弹窗渲染都统一到外层一个标签内，从而方便控制。</p><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验<br>使用步骤：<br>&emsp;&emsp;异步引入组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">import &#123;defineAsyncComponent&#125; from <span class="hljs-string">&#x27;vue&#x27;</span><br>const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;))<br>使用Suspense包裹组件，并配置好default 与 fallback<br><br>&lt;template&gt;<br>&lt;div class=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>&lt;h3&gt;我是App组件&lt;/h3&gt;<br>&lt;Suspense&gt;<br>&lt;template v-slot:default&gt;<br>&lt;Child/&gt;<br>&lt;/template&gt;<br>&lt;template v-slot:fallback&gt;<br>&lt;h3&gt;加载中.....&lt;/h3&gt;<br>&lt;/template&gt;<br>&lt;/Suspense&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><p>Vue 2.x 有许多全局 API 和配置。</p><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">//注册全局组件<br>Vue.component(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  data: () =&gt; (&#123;<br>    count: 0<br>  &#125;),<br>  template: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br>​<br>//注册全局指令<br>Vue.directive(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  inserted: el =&gt; el.focus()<br>&#125;<br></code></pre></td></tr></table></figure><p>Vue3.0中对这些API做出了调整：</p><p>将全局的API，即：Vue.xxx调整到应用实例（app）上</p><p>2.x 全局 API（Vue）3.x 实例 API (app)<br>Vue.config.xxxx —&gt;app.config.xxxx<br>Vue.config.productionTip —&gt;移除<br>Vue.component —&gt;app.component<br>Vue.directive —&gt;app.directive<br>Vue.mixin —&gt;app.mixin<br>Vue.use —&gt;app.use<br>Vue.prototype —&gt;app.config.globalProperties</p><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><p>data选项应始终被声明为一个函数。</p><p>过度类名的更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue2.x写法<br>.v-enter,<br>.v-leave-to &#123;<br>  opacity: 0;<br>&#125;<br>.v-leave,<br>.v-enter-to &#123;<br>  opacity: 1;<br>&#125;<br><br>Vue3.x写法<br>.v-enter-from,<br>.v-leave-to &#123;<br>  opacity: 0;<br>&#125;<br><br>.v-leave-from,<br>.v-enter-to &#123;<br>  opacity: 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes<br>移除v-on.native修饰符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">父组件中绑定事件<br><br>&lt;my-component<br>  v-on:close=<span class="hljs-string">&quot;handleComponentEvent&quot;</span><br>  v-on:click=<span class="hljs-string">&quot;handleNativeClickEvent&quot;</span><br>/&gt;<br>子组件中声明自定义事件<br><br>&lt;script&gt;<br>  <span class="hljs-built_in">export</span> default &#123;<br>    emits: [<span class="hljs-string">&#x27;close&#x27;</span>]<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>移除过滤器（filter）</p><p class="note note-primary">过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p><p>全局注册改变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">import global from <span class="hljs-string">&quot;@/utils/global&quot;</span><br><br>//在vue2中<br>vue.prototype.<span class="hljs-variable">$global</span> = global;<br>//在vue3中<br>app.config.globalProperties.<span class="hljs-variable">$global</span> = global;<br><br>//在任一vue组建中使用<br>this.<span class="hljs-variable">$global</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3 基础-toRef</title>
    <link href="/2021/10/09/vue3%20%E5%9F%BA%E7%A1%80-toRef/"/>
    <url>/2021/10/09/vue3%20%E5%9F%BA%E7%A1%80-toRef/</url>
    
    <content type="html"><![CDATA[<h1 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h1><p>作用： 为原响应式对象上的某个属性创建一个 ref 对象, 二者内部操作的是同一个数据值, 更新时二者是同步的。<br>语法： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">const xxx = toRef(响应式对象, <span class="hljs-string">&quot;对象属性&quot;</span>);<br></code></pre></td></tr></table></figure><p>和ref区别：<br>&emsp;&emsp;ref拷贝了一份新的数据值单独操作, 更新时相互不影响<br>&emsp;&emsp;toRef引用原响应对象数据，更新时二者是同步的<br>应用: 使用父组件传递的props数据时，要引用props的某个属性且要保持响应式连接时就很有用。</p><p>toRefFather.vue</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>  &lt;h2&gt;Father&lt;/h2&gt;<br>  &lt;p&gt;user: &#123;&#123; user &#125;&#125;&lt;/p&gt;<br>  &lt;p&gt;nameToRef: &#123;&#123; nameToRef &#125;&#125;&lt;/p&gt;<br>  &lt;p&gt;nameRef: &#123;&#123; nameRef &#125;&#125;&lt;/p&gt;<br><br>  &lt;button @click=<span class="hljs-string">&quot;update&quot;</span>&gt;更新&lt;/button&gt;<br><br>  &lt;Child :name=<span class="hljs-string">&quot;nameToRef&quot;</span> /&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span>&gt;<br>import &#123; reactive, toRef, ref &#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br>import Child from <span class="hljs-string">&quot;../components/toRefChild.vue&quot;</span>;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span></span>() &#123;<br><br>    const user = reactive(&#123;<br>      name: <span class="hljs-string">&#x27;温情key&#x27;</span>,<br>      age: 22,<br>    &#125;);<br><br>    const nameToRef = toRef(user, <span class="hljs-string">&quot;name&quot;</span>);<br>    const nameRef = ref(user.name);<br><br>    const update = () =&gt; &#123;<br>      user.name = user.name + <span class="hljs-string">&#x27;y&#x27;</span>;<br>      // nameToRef.value = nameToRef.value + <span class="hljs-string">&#x27;y&#x27;</span>;<br>      nameRef.value = <span class="hljs-string">&#x27;ref拷贝一份新数据，不影响原对象数据&#x27;</span>;<br>    &#125;;<br><br>    <span class="hljs-built_in">return</span> &#123;<br>      user,<br>      nameToRef,<br>      nameRef,<br>      update,<br>    &#125;;<br>  &#125;,<br><br>  components: &#123;<br>    Child,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>toRefChild.vue</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>  &lt;h2&gt;Child&lt;/h2&gt;<br>  &lt;h3&gt;nameToRef: &#123;&#123; name &#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span>&gt;<br>import &#123; computed, defineComponent, Ref, toRef &#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br><br>const component = defineComponent(&#123;<br>  props: &#123;<br>    name: &#123;<br>      <span class="hljs-built_in">type</span>: String,<br>      require: <span class="hljs-literal">true</span>,<br>    &#125;,<br>  &#125;,<br><br>  setup(props, context) &#123;<br>   <br>    <span class="hljs-built_in">return</span> &#123;<br>      <br>    &#125;;<br>  &#125;,<br>&#125;);<br><br><span class="hljs-built_in">export</span> default component;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p class="note note-primary">    用toRef 单独获取响应式对象中属性，保持响应式，使用或者改变一同改变。    ref取响应式对象中属性，会拷贝新建一个完全独立的响应式数据，改变不相互影响。</p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex 模块化开发</title>
    <link href="/2021/03/12/vuex%20%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <url>/2021/03/12/vuex%20%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="首先来简单介绍一下vuex"><a href="#首先来简单介绍一下vuex" class="headerlink" title="首先来简单介绍一下vuex"></a>首先来简单介绍一下vuex</h2><p>Vuex 是一个用于状态管理的库，它是为 Vue.js 应用程序开发的，旨在帮助管理数据的流动和共享。</p><p>状态（State）：单一状态树（State Tree）是存储整个应用程序状态的地方。状态是保存在 Vuex 中的集中式公共数据源，可以通过 this.$store.state 访问（当然你得挂载全局vue2中：Vue.prototype.axios &#x3D; axios; vue3就用app.config.globalProperties.$axios &#x3D; axios;）。它通常被看作是应用程序的唯一数据源。</p><p>Getter：Getter 允许从存储在 Vuex 中的状态派生出新的状态。类似于 Vue 组件中的计算属性，Getter 可以对状态进行处理和计算，并将结果暴露给其他组件使用。</p><p>Mutation：Mutation 是修改状态的唯一方式。Mutation 必须是同步函数，用于更改状态并跟踪状态变化。它们在提交时需要调用 commit 方法，并接收一个参数来传递数据载荷（Payload）。只有 Mutation 才能修改状态，这样确保了状态的变更可追踪和可维护性。</p><p>Action：Action 用于处理异步操作或包含多个 Mutation 的复杂操作。Action 可以包含任意异步操作，例如从服务器获取数据后提交 Mutation 来更新状态。Action 在组件中通过调用 dispatch 方法来触发，可以接收一个 Promise，以便异步操作完成后再提交 Mutation。</p><p>Module：Module 允许将 Vuex 分割成单个模块。每个模块拥有自己的状态、Getter、Mutation 和 Action，可以嵌套引用其他模块。这样组织代码可以更好地扩展和维护，并且可以在不同模块之间共享状态。</p><p class="note note-primary">实现全局状态的集中管理，使不同组件之间能够方便地共享和更新状态。（常用于权限控制，用户状态等）</p><h2 id="组合式开发"><a href="#组合式开发" class="headerlink" title="组合式开发"></a>组合式开发</h2><p>首先创建一个store文件夹，创建一个index.js文件，引入Vue和Vuex，如果需要模块化开发就在index.js文件夹中引入创建的另外store仓库js文件，然后通过modules 把他们两个合并起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">// store/index.js<br>import Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br>//引入Vuex<br>import Vuex from <span class="hljs-string">&#x27;vuex&#x27;</span><br>import countOptions from <span class="hljs-string">&#x27;./count&#x27;</span><br>import personOptions from <span class="hljs-string">&#x27;./person&#x27;</span><br>//应用Vuex插件<br>Vue.use(Vuex)<br> <br>//创建并暴露store<br><span class="hljs-built_in">export</span> default new Vuex.Store(&#123;<br>modules:&#123;<br>countAbout:countOptions,<br>personAbout:personOptions<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上代码中 .&#x2F;count 属于count仓库。<br>count仓库中有五大属性 分为 actions，mutations，state，getters，modules</p><p class="note note-primary">namespaced:true， 这个配置是独立命名空间，如果false将都处于同一命名空间，模块化就只是写法上分开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">//求和相关的配置<br><span class="hljs-built_in">export</span> default &#123;<br>namespaced:<span class="hljs-literal">true</span>,<br>actions:&#123;<br>jiaOdd(context,value)&#123;<br>console.log(<span class="hljs-string">&#x27;actions中的jiaOdd被调用了&#x27;</span>)<br><span class="hljs-keyword">if</span>(context.state.sum % 2)&#123;<br>context.commit(<span class="hljs-string">&#x27;JIA&#x27;</span>,value)<br>&#125;<br>&#125;,<br>jiaWait(context,value)&#123;<br>console.log(<span class="hljs-string">&#x27;actions中的jiaWait被调用了&#x27;</span>)<br>setTimeout(()=&gt;&#123;<br>context.commit(&#x27;JIA&#x27;,value)<br>&#125;,<span class="hljs-number">500</span>)<br>&#125;<br>&#125;,<br>mutations:&#123;<br>JIA(state,value)&#123;<br>console.log(&#x27;mutations中的JIA被调用了&#x27;)<br>state.sum += value<br>&#125;,<br>JIAN(state,value)&#123;<br>console.log(&#x27;mutations中的JIAN被调用了&#x27;)<br>state.sum -= value<br>&#125;,<br>&#125;,<br>state:&#123;<br>sum:<span class="hljs-number">0</span>, //当前的和<br>school:&#x27;不知名&#x27;,<br>subject:&#x27;前端&#x27;,<br>&#125;,<br>getters:&#123;<br>bigSum(state)&#123;<br>return state.sum*<span class="hljs-number">10</span><br>&#125;<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vue模块化就完成了，下面来看一下使用"><a href="#vue模块化就完成了，下面来看一下使用" class="headerlink" title="vue模块化就完成了，下面来看一下使用"></a>vue模块化就完成了，下面来看一下使用</h2><p>方法1：vuex的优化函数 使用map…</p><p>首先引入 四种方法,import {mapState,mapGetters,mapMutations,mapActions} from ‘vuex’<br>在计算属性computed中可以展开 mapState, mapGetters 来获取数据<br>在methods 中可以展开 mapMutations mapActions 来派发actions方法,或者直接修改mutations中的数据<br>…mapState(‘countAbout’,[‘sum’,’school’,’subject’]), 第一个参数意思是从模块化modules中的countAbout 获取数据,第二个参数是 countAbout文件中获取state数据,是一个数组<br>method中 …mapMutations(‘countAbout’,{increment:’JIA’,decrement:’JIAN’}),<br>第一个参数是模块化名字,第二个参数是键值对形式,键是ui页面中触发的方法,第二个参数是mutilation中对应的的方法 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h1&gt;当前求和为：&#123;&#123;<span class="hljs-built_in">sum</span>&#125;&#125;&lt;/h1&gt;<br>&lt;h3&gt;当前求和放大10倍为：&#123;&#123;bigSum&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;我在&#123;&#123;school&#125;&#125;，学习&#123;&#123;subject&#125;&#125;&lt;/h3&gt;<br>&lt;h3 style=<span class="hljs-string">&quot;color:red&quot;</span>&gt;Person组件的总人数是：&#123;&#123;personList.length&#125;&#125;&lt;/h3&gt;<br>&lt;<span class="hljs-keyword">select</span> v-model.number=<span class="hljs-string">&quot;n&quot;</span>&gt;<br>&lt;option value=<span class="hljs-string">&quot;1&quot;</span>&gt;1&lt;/option&gt;<br>&lt;option value=<span class="hljs-string">&quot;2&quot;</span>&gt;2&lt;/option&gt;<br>&lt;option value=<span class="hljs-string">&quot;3&quot;</span>&gt;3&lt;/option&gt;<br>&lt;/select&gt;<br>&lt;button @click=<span class="hljs-string">&quot;increment(n)&quot;</span>&gt;+&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;decrement(n)&quot;</span>&gt;-&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;incrementOdd(n)&quot;</span>&gt;当前求和为奇数再加&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;incrementWait(n)&quot;</span>&gt;等一等再加&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br> <br>&lt;script&gt;<br>import &#123;mapState,mapGetters,mapMutations,mapActions&#125; from <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-built_in">export</span> default &#123;<br>name:<span class="hljs-string">&#x27;Count&#x27;</span>,<br><span class="hljs-function"><span class="hljs-title">data</span></span>() &#123;<br><span class="hljs-built_in">return</span> &#123;<br>n:1, //用户选择的数字<br>&#125;<br>&#125;,<br>computed:&#123;<br>//借助mapState生成计算属性，从state中读取数据。（数组写法）<br>...mapState(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>]),<br>...mapState(<span class="hljs-string">&#x27;personAbout&#x27;</span>,[<span class="hljs-string">&#x27;personList&#x27;</span>]),<br>//借助mapGetters生成计算属性，从getters中读取数据。（数组写法）<br>...mapGetters(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br>&#125;,<br>methods: &#123;<br>//借助mapMutations生成对应的方法，方法中会调用commit去联系mutations(对象写法)<br>...mapMutations(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;increment:<span class="hljs-string">&#x27;JIA&#x27;</span>,decrement:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br>//借助mapActions生成对应的方法，方法中会调用dispatch去联系actions(对象写法)<br>...mapActions(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;incrementOdd:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,incrementWait:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">mounted</span></span>() &#123;<br>console.log(this.<span class="hljs-variable">$store</span>)<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br> <br>&lt;style lang=<span class="hljs-string">&quot;css&quot;</span>&gt;<br>button&#123;<br>margin-left: 5px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>方法2：通过挂载方式获取store来使用</p><p>首先 需要在入口文件中引入store并把挂载到vm身上<br>然后就可以在页面中通过  this.$store.state.personAbout 获取personAbout<br>模块中的数据<br>通过this.$store.getters[‘personAbout&#x2F;firstPersonName’]获取仓库中的计算属性数据<br>通过this.$store.commit(‘personAbout&#x2F;ADD_PERSON’,personObj)<br>触发 personAbout仓库中mutions的方法 commit 是直接触发mutions方法中的函数,一般不需要异步操作就可以直接使用这种方式,<br>通过this.$store.dispatch(‘personAbout&#x2F;addPersonWang’,personObj)<br>触发 action中的异步方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs bash">//main.js<br>//引入Vue<br>import Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br>//引入App<br>import App from <span class="hljs-string">&#x27;./App.vue&#x27;</span><br>//引入插件<br>import vueResource from <span class="hljs-string">&#x27;vue-resource&#x27;</span><br>//引入store<br>import store from <span class="hljs-string">&#x27;./store&#x27;</span><br> <br>//关闭Vue的生产提示<br>Vue.config.productionTip = <span class="hljs-literal">false</span><br>//使用插件<br>Vue.use(vueResource)<br> <br>//创建vm<br>new Vue(&#123;<br>el:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>render: h =&gt; h(App),<br>store,<br><span class="hljs-function"><span class="hljs-title">beforeCreate</span></span>() &#123;<br>Vue.prototype.<span class="hljs-variable">$bus</span> = this<br>&#125;<br>&#125;)<br>``` bash<br>&lt;!-- person.vue --&gt;<br>&lt;template&gt;<br>&lt;div&gt;<br>&lt;h1&gt;人员列表&lt;/h1&gt;<br>&lt;h3 style=<span class="hljs-string">&quot;color:red&quot;</span>&gt;Count组件求和为：&#123;&#123;<span class="hljs-built_in">sum</span>&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;列表中第一个人的名字是：&#123;&#123;firstPersonName&#125;&#125;&lt;/h3&gt;<br>&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> placeholder=<span class="hljs-string">&quot;请输入名字&quot;</span> v-model=<span class="hljs-string">&quot;name&quot;</span>&gt;<br>&lt;button @click=<span class="hljs-string">&quot;add&quot;</span>&gt;添加&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;addWang&quot;</span>&gt;添加一个姓王的人&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;addPersonServer&quot;</span>&gt;添加一个人，名字随机&lt;/button&gt;<br>&lt;ul&gt;<br>&lt;li v-for=<span class="hljs-string">&quot;p in personList&quot;</span> :key=<span class="hljs-string">&quot;p.id&quot;</span>&gt;&#123;&#123;p.name&#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br> <br>&lt;script&gt;<br>import &#123;nanoid&#125; from <span class="hljs-string">&#x27;nanoid&#x27;</span><br><span class="hljs-built_in">export</span> default &#123;<br>name:<span class="hljs-string">&#x27;Person&#x27;</span>,<br><span class="hljs-function"><span class="hljs-title">data</span></span>() &#123;<br><span class="hljs-built_in">return</span> &#123;<br>name:<span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br>&#125;,<br>computed:&#123;<br><span class="hljs-function"><span class="hljs-title">personList</span></span>()&#123;<br><span class="hljs-built_in">return</span> this.<span class="hljs-variable">$store</span>.state.personAbout.personList<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">sum</span></span>()&#123;<br><span class="hljs-built_in">return</span> this.<span class="hljs-variable">$store</span>.state.countAbout.<span class="hljs-built_in">sum</span><br>&#125;,<br><span class="hljs-function"><span class="hljs-title">firstPersonName</span></span>()&#123;<br><span class="hljs-built_in">return</span> this.<span class="hljs-variable">$store</span>.getters[<span class="hljs-string">&#x27;personAbout/firstPersonName&#x27;</span>]<br>&#125;<br>&#125;,<br>methods: &#123;<br><span class="hljs-function"><span class="hljs-title">add</span></span>()&#123;<br>const personObj = &#123;<span class="hljs-built_in">id</span>:nanoid(),name:this.name&#125;<br>this.<span class="hljs-variable">$store</span>.commit(<span class="hljs-string">&#x27;personAbout/ADD_PERSON&#x27;</span>,personObj)<br>this.name = <span class="hljs-string">&#x27;&#x27;</span><br>&#125;,<br><span class="hljs-function"><span class="hljs-title">addWang</span></span>()&#123;<br>const personObj = &#123;<span class="hljs-built_in">id</span>:nanoid(),name:this.name&#125;<br>this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&#x27;personAbout/addPersonWang&#x27;</span>,personObj)<br>this.name = <span class="hljs-string">&#x27;&#x27;</span><br>&#125;,<br><span class="hljs-function"><span class="hljs-title">addPersonServer</span></span>()&#123;<br>this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&#x27;personAbout/addPersonServer&#x27;</span>)<br>&#125;<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash">//person.js<br>//人员管理相关的配置<br>import axios from <span class="hljs-string">&#x27;axios&#x27;</span><br>import &#123; nanoid &#125; from <span class="hljs-string">&#x27;nanoid&#x27;</span><br><span class="hljs-built_in">export</span> default &#123;<br>namespaced:<span class="hljs-literal">true</span>,<br>actions:&#123;<br>addPersonWang(context,value)&#123;<br><span class="hljs-keyword">if</span>(value.name.indexOf(<span class="hljs-string">&#x27;王&#x27;</span>) === 0)&#123;<br>context.commit(<span class="hljs-string">&#x27;ADD_PERSON&#x27;</span>,value)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>alert(<span class="hljs-string">&#x27;添加的人必须姓王！&#x27;</span>)<br>&#125;<br>&#125;,<br>addPersonServer(context)&#123;<br>axios.get(<span class="hljs-string">&#x27;https://api.uixsj.cn/hitokoto/get?type=social&#x27;</span>).<span class="hljs-keyword">then</span>(<br>response =&gt; &#123;<br>context.commit(<span class="hljs-string">&#x27;ADD_PERSON&#x27;</span>,&#123;<span class="hljs-built_in">id</span>:nanoid(),name:response.data&#125;)<br>&#125;,<br>error =&gt; &#123;<br>alert(error.message)<br>&#125;<br>)<br>&#125;<br>&#125;,<br>mutations:&#123;<br>ADD_PERSON(state,value)&#123;<br>console.log(<span class="hljs-string">&#x27;mutations中的ADD_PERSON被调用了&#x27;</span>)<br>state.personList.unshift(value)<br>&#125;<br>&#125;,<br>state:&#123;<br>personList:[<br>&#123;<span class="hljs-built_in">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,name:<span class="hljs-string">&#x27;张三&#x27;</span>&#125;<br>]<br>&#125;,<br>getters:&#123;<br>firstPersonName(state)&#123;<br><span class="hljs-built_in">return</span> state.personList[0].name<br>&#125;<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vuex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vuex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html 基础-空格符号</title>
    <link href="/2021/02/27/html%20%E5%9F%BA%E7%A1%80-%E7%A9%BA%E6%A0%BC/"/>
    <url>/2021/02/27/html%20%E5%9F%BA%E7%A1%80-%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="html中的空格符号-nbsp-ensp-emsp"><a href="#html中的空格符号-nbsp-ensp-emsp" class="headerlink" title="html中的空格符号  nbsp; ensp; emsp;"></a>html中的空格符号  nbsp; ensp; emsp;</h1><h2 id="不同空格符合的区别"><a href="#不同空格符合的区别" class="headerlink" title="不同空格符合的区别"></a>不同空格符合的区别</h2><p>我是开始&nbsp;半角的不断行的空白格（推荐使用）<br>我是开始&ensp;半角的空格<br>我是开始&emsp;全角的空格</p><p>&amp;nbsp; 这是我们使用最多的空格，也就是按下space键产生的空格。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加。该空格占据宽度受字体影响明显而强烈。在inline-block布局中会搞些小破坏，在两端对齐布局中又是不可少的元素。</p><p>&amp;ensp; 此空格有个相当稳健的特性，就是其占据的宽度正好是1&#x2F;2个中文宽度，而且基本上不受字体影响。<br>&amp;emsp; 此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于&amp;ensp;和&amp;emsp;在一些中文排版对齐方面可以使用，如下html代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;ul&gt;<br>    &lt;li class=<span class="hljs-string">&quot;li&quot;</span>&gt;姓&amp;emsp;&amp;emsp;名：&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;&lt;/li&gt;<br>    &lt;li class=<span class="hljs-string">&quot;li&quot;</span>&gt;手&amp;ensp;机&amp;ensp;号：&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;&lt;/li&gt;<br>    &lt;li class=<span class="hljs-string">&quot;li&quot;</span>&gt;电子邮箱：&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><ul>    <li class="li">姓&emsp;&emsp;名：<input type="text" /></li>    <li class="li">手&ensp;机&ensp;号：<input type="text" /></li>    <li class="li">电子邮箱：<input type="text" /></li></ul><p class="note note-warning">注意：上面的空白字符中文对齐方法在IE6下不能完全兼容。（可以使用css样式来调整，不过谁还用IE！）</p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
      <category>空格</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>script 基础-循环</title>
    <link href="/2020/01/01/script%20%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF/"/>
    <url>/2020/01/01/script%20%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript数组循环"><a href="#JavaScript数组循环" class="headerlink" title="JavaScript数组循环"></a>JavaScript数组循环</h1><p>利用Javascript map(),reduce()和filter()数组方法可以帮助您编写更加声明性、流畅的风格代码。</p><p>而不是积累起来for循环和嵌套来处理列表和集合中的数据，您可以利用这些方法更好地将逻辑组织成功能的构建块，然后将它们链接起来以创建更可读和更易于理解的实现。</p><p>ES6还为我们提供了一些更好的数组方法，比如.find,.findIndex,.of和for..of循环！</p><h2 id="数组循环"><a href="#数组循环" class="headerlink" title="数组循环"></a>数组循环</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officers = [<br>    &#123; <span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&#x27;Captain Piett&#x27;</span> &#125;,<br>    &#123; <span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&#x27;General Veers&#x27;</span> &#125;,<br>    &#123; <span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&#x27;Admiral Ozzel&#x27;</span> &#125;,<br>    &#123; <span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&#x27;Commander Jerjerrod&#x27;</span> &#125;<br>];<br>// What you need<br>// [20, 24, 56, 88]<br></code></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>使用率最高，也是最基本的一种遍历方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officersIds = [];<br><span class="hljs-keyword">for</span>(var i=0,len=officers.length;i&lt;len; i++)&#123;<br>    officersIds.push(officers[i].<span class="hljs-built_in">id</span>);<br>&#125;<br>console.log(officersIds); // [20,24,56,88]<br></code></pre></td></tr></table></figure><h2 id="forEach循环"><a href="#forEach循环" class="headerlink" title="forEach循环"></a>forEach循环</h2><p>forEach中传入要执行的回调函数，函数有三个参数。第一个参数为数组元素(必选)，第二个参数为数组元素索引值(可选)，第三个参数为数组本身(可选)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officersIds = [];<br>officers.forEach(<span class="hljs-keyword">function</span> (officer,index,array) &#123;<br>    console.log(index); //0,1,2,3,<br>    console.log(officer); //&#123;<span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&quot;Captain Piett&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&quot;General Veers&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&quot;Admiral Ozzel&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&quot;Commander Jerjerrod&quot;</span>&#125;<br>    officersIds.push(officer.id);<br>&#125;);<br>console.log(officersIds); //[20,24,56,88]<br></code></pre></td></tr></table></figure><h2 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for in循环"></a>for in循环</h2><p>for…in循环可用于循环对象和数组,推荐用于循环对象,可以用来遍历JSON</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officersIds = [];<br><span class="hljs-keyword">for</span>(var key <span class="hljs-keyword">in</span> officers)&#123;<br>    console.log(key); // 0 1 2 3 返回数组索引<br>    console.log(officers[key]); //&#123;<span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&quot;Captain Piett&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&quot;General Veers&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&quot;Admiral Ozzel&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&quot;Commander Jerjerrod&quot;</span>&#125;<br>    officersIds.push(officers[key].<span class="hljs-built_in">id</span>);<br>&#125;<br>console.log(officersIds); //[20,24,56,88]<br></code></pre></td></tr></table></figure><h2 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for of循环"></a>for of循环</h2><p>可循环数组和对象，推荐用于遍历数组。</p><p>for…of提供了三个新方法：</p><p>key()是对键名的遍历；<br>value()是对键值的遍历；<br>entries()是对键值对的遍历；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> arr = [<span class="hljs-string">&#x27;科大讯飞&#x27;</span>, <span class="hljs-string">&#x27;政法BG&#x27;</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item of arr) &#123;  <br>  console.log(item); //  科大讯飞  政法BG  前端开发<br>&#125;<br>// 输出数组索引<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item of arr.keys()) &#123;  <br>  console.log(item);  // 0 1 2<br>&#125;<br>// 输出内容和索引<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> [item, val] of arr.entries()) &#123;  <br>  console.log(item + <span class="hljs-string">&#x27;:&#x27;</span> + val); //  0:科大讯飞  1：政法BG  2：前端开发<br>&#125;<br><br>var officersIds = [];<br><span class="hljs-keyword">for</span> (var item of officers) &#123;<br>    console.log(item); //&#123;<span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&quot;Captain Piett&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&quot;General Veers&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&quot;Admiral Ozzel&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&quot;Commander Jerjerrod&quot;</span>&#125;<br>    officersIds.push(item.id); <br>&#125;<br>console.log(officersIds); // [20,24,56,88]<br>// 输出数组索引<br><span class="hljs-keyword">for</span>(var item of officers.keys())&#123;<br>    console.log(item); // 0 1 2 3<br>&#125;<br>// 输出内容和索引<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> [item, val] of officers.entries()) &#123;<br>    console.log(item) // 0 1 2 3 输出数组索引<br>    console.log(val);//&#123;<span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&quot;Captain Piett&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&quot;General Veers&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&quot;Admiral Ozzel&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&quot;Commander Jerjerrod&quot;</span>&#125;<br>    console.log(item + <span class="hljs-string">&#x27;:&#x27;</span> + val); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="map循环"><a href="#map循环" class="headerlink" title="map循环"></a>map循环</h2><p>map() 会返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。<br>map() 方法按照原始数组元素顺序依次处理元素。</p><p>map 不修改调用它的原数组本身。</p><p>map()中传入要执行的回调函数，函数有三个参数。第一个参数为数组元素(必选)，第二个参数为数组元素索引值(可选)，第三个参数为数组本身(可选)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">var arr = [<br>    &#123;name:<span class="hljs-string">&#x27;a&#x27;</span>,age:<span class="hljs-string">&#x27;18&#x27;</span>&#125;,<br>    &#123;name:<span class="hljs-string">&#x27;b&#x27;</span>,age:<span class="hljs-string">&#x27;19&#x27;</span>&#125;,<br>    &#123;name:<span class="hljs-string">&#x27;c&#x27;</span>,age:<span class="hljs-string">&#x27;20&#x27;</span>&#125;<br>];<br>arr.map(<span class="hljs-keyword">function</span>(item,index) &#123;<br>    <span class="hljs-keyword">if</span>(item.name == <span class="hljs-string">&#x27;b&#x27;</span>) &#123;<br>        console.log(index)  // 1<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>数组加一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officersIds = officers.map(<span class="hljs-keyword">function</span> (officer) &#123;<br>    <span class="hljs-built_in">return</span> officer.id<br>&#125;);<br>console.log(officersIds); //[20,24,56,88]<br></code></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">array.reduce(<span class="hljs-keyword">function</span> callback(accumulator, currentValue, currentIndex, array)&#123;<br><br>&#125;[, initialValue])<br><br>var peoples = [<br>  &#123;<br>    <span class="hljs-built_in">id</span>: 10,<br>    name: <span class="hljs-string">&quot;Poe Dameron&quot;</span>,<br>    years: 14,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-built_in">id</span>: 2,<br>    name: <span class="hljs-string">&quot;Temmin &#x27;Snap&#x27; Wexley&quot;</span>,<br>    years: 30,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-built_in">id</span>: 41,<br>    name: <span class="hljs-string">&quot;Tallissan Lintra&quot;</span>,<br>    years: 16,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-built_in">id</span>: 99,<br>    name: <span class="hljs-string">&quot;Ello Asty&quot;</span>,<br>    years: 22,<br>  &#125;<br>];<br></code></pre></td></tr></table></figure><h3 id="输出他们的年龄总数"><a href="#输出他们的年龄总数" class="headerlink" title="输出他们的年龄总数"></a>输出他们的年龄总数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var totalYears = peoples.reduce(<span class="hljs-keyword">function</span> (total, people) &#123;<br>    console.log(total);<br>    console.log(people);<br>    <span class="hljs-built_in">return</span> total + people.years;<br>&#125;, 0);<br>// const totalYears = people.reduce((acc, people) =&gt; acc + people.years, <span class="hljs-number">0</span>);<br>console.log(totalYears); //<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><h3 id="求年龄最大的那个人"><a href="#求年龄最大的那个人" class="headerlink" title="求年龄最大的那个人"></a>求年龄最大的那个人</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var oldest = peoples.reduce(<span class="hljs-keyword">function</span> (oldest, people) &#123;<br>    <span class="hljs-built_in">return</span> (oldest.years || 0) &gt; people.years ? oldest : people;<br>&#125;, &#123;&#125;);<br>console.log(oldest); //&#123;<span class="hljs-built_in">id</span>: 2, name: <span class="hljs-string">&quot;Temmin &#x27;Snap&#x27; Wexley&quot;</span>, years: 30&#125;<br>console.log(oldest.years); //82<br></code></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">array.filter(<span class="hljs-keyword">function</span>(currentValue,index,arr)&#123;<br><br>&#125;, thisValue)<br></code></pre></td></tr></table></figure><p>演示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">var designer = peoples.filter(<span class="hljs-keyword">function</span> (people) &#123;<br>    <span class="hljs-built_in">return</span> people.job === <span class="hljs-string">&quot;designer&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">var totalScore = peoples<br>    .filter(<span class="hljs-keyword">function</span> (person) &#123;<br>        <span class="hljs-built_in">return</span> person.isForceUser;<br>    &#125;)<br>    .map(<span class="hljs-keyword">function</span> (choose) &#123;<br>        <span class="hljs-built_in">return</span> choose.mathScore + choose.englishScore;<br>    &#125;)<br>    .reduce(<span class="hljs-keyword">function</span> (total, score) &#123;<br>        <span class="hljs-built_in">return</span> total + score;<br>    &#125;, 0);<br></code></pre></td></tr></table></figure><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">var divs = document.querySelectorAll(<span class="hljs-string">&#x27;div.pane&#x27;</span>);  <br>var text = Array.from(divs, (d) =&gt; d.textContent);  <br>console.log(<span class="hljs-string">&quot;div text:&quot;</span>, text);<br><br>// Old, ES5 way to get array from arguments<br><span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;  <br>  var args = [].slice.call(arguments);<br>  //...<br>&#125;<br><br>// Using ES6 Array.from<br><span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;  <br>  var args = Array.from(arguments);<br>  //..<br>&#125;<br><br>var filled = Array.from([1,,2,,3], (n) =&gt; n || 0);  <br>console.log(<span class="hljs-string">&quot;filled:&quot;</span>, filled);  <br>// =\&gt; [1,0,2,0,3]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>循环</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
