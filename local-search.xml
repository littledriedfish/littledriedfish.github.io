<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue html转图片和pdf 并需要分页留边距</title>
    <link href="/2024/02/24/vue%20html%E8%BD%AC%E5%9B%BE%E7%89%87%E5%92%8Cpdf/"/>
    <url>/2024/02/24/vue%20html%E8%BD%AC%E5%9B%BE%E7%89%87%E5%92%8Cpdf/</url>
    
    <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>如果要将html 转为图片，可以使用 html2canvas，或者转为pdf 可以使用jsPDF。但当页面内容较多或者页面内容不确定长短时，html直接转pdf分页上就会出现问题，无法调节下边距：<br><img src="/images/jsPdf.png" alt="图片" title=" "></p><h1 id="另辟蹊径"><a href="#另辟蹊径" class="headerlink" title="另辟蹊径"></a>另辟蹊径</h1><p>使用html2canvas 把html转化为的图片进行裁剪（裁剪大小正好是一页），再贴图生成pdf。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save html2canvas<br>npm install --save jspdf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">import html2canvas from <span class="hljs-string">&#x27;html2canvas&#x27;</span>;<br>import jsPDF from <span class="hljs-string">&#x27;jsPDF&#x27;</span>; <br></code></pre></td></tr></table></figure><p>直接贴码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs bash">......<br>&lt;div <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;pdfDom&quot;</span>&gt;内容&lt;/div&gt;<br>&lt;img :url=<span class="hljs-string">&quot;url&quot;</span> /&gt;<br>......<br><br><span class="hljs-function"><span class="hljs-title">data</span></span>() &#123;<br>    <span class="hljs-built_in">return</span> &#123; <br>        url: <span class="hljs-string">&#x27;&#x27;</span>,//pdf 预览图<br>    &#125;<br>&#125;,<br>methods: &#123;<br>    // html转图片 pdf<br>    <span class="hljs-function"><span class="hljs-title">getImgPdf</span></span>() &#123;<br>        window.scrollTo(0,0)<br>        // 生成pdf文件流<br>        var elem =document.getElementById(<span class="hljs-string">&#x27;pdfDom&#x27;</span>);<br>        html2canvas(elem,&#123;<br>            allowTaint: <span class="hljs-literal">false</span>, // 是否允许跨域图像。会污染画布，导致无法使用canvas.toDataURL 方法<br>            backgroundColor: <span class="hljs-string">&#x27;#fff&#x27;</span>, // 画布背景色（如果未在DOM中指定）。设置null为透明<br>            useCORS: <span class="hljs-literal">true</span>, // 是否尝试使用CORS从服务器加载图像<br>            dpi: 192, // 导出pdf清晰度<br>            scale: window.devicePixelRatio * 3, // 用于渲染的比例。默认为浏览器设备像素比率。<br>        &#125;).<span class="hljs-keyword">then</span>( canvas =&gt; &#123;<br>            // html生成图片的数据<br>            var imageData = canvas.toDataURL();<br>            this.url = imageData;<br><br>            //上传图片 （项目需求这里上传图片）<br>            // 生成随机名<br>            <span class="hljs-built_in">let</span> randnum = Math.random() * 10000000000000<br>            randnum = Math.floor(randnum)<br>            <span class="hljs-built_in">let</span> fileName = <span class="hljs-string">&quot;fys&quot;</span> + randnum + <span class="hljs-string">&#x27;.png&#x27;</span><br>            // 转换为文件<br>            <span class="hljs-built_in">let</span> file = this.dataURLtoFile(imageData, fileName)<br>            // 文件上传<br>            this.upFile(file)<br><br>            //开始pdf生成<br>            //创绘制切割后绘制canvas用的canvas标签以及对应的context对象<br>            const perCanvas = document.createElement(<span class="hljs-string">&#x27;canvas&#x27;</span>);<br>            perCanvas.style.backgroundColor = <span class="hljs-string">&#x27;#fff&#x27;</span><br>            const context  = perCanvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);<br>            // 将需要下载的html标签转成canvas标签，并获取对应的<span class="hljs-built_in">base64</span>码<br>            const canvasData = canvas.toDataURL();<br>            // pdf的尺寸<br>            const pdfWidth = canvas.width;<br>            const pdfHeight = pdfWidth * 1.414;<br>            //切割后的canvas图片的宽高，就等于每页pdf的宽高<br>            perCanvas.width = canvas.width;<br>            perCanvas.height = pdfHeight;<br>            // 每张图片的高度：适当减少100，上下各留50页边距<br>            const perHeight = pdfHeight - 100;<br>            // 计算切割次数<br>            <span class="hljs-built_in">let</span> splitCount = Math.ceil(canvas.height / perHeight);<br>            <span class="hljs-keyword">if</span>(splitCount * perHeight &lt; canvas.height) splitCount++;<br>            //创建img对象，加载完整的canvas图片<br>            const img = new Image();<br>            img.src = canvasData;<br>            //创建pdf对象<br>            const pdf = new jsPDF(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;pt&#x27;</span>, [pdfWidth, pdfHeight]);<br>            //待图片加载完成<br>            setTimeout(() =&gt; &#123;<br>                //切割canvas图片，贴到每一页pdf中<br>                for (let i = <span class="hljs-number">0</span>; i &lt; splitCount; i++) &#123;<br>                    const startY = i * perHeight; // 起始y坐标<br>                    // 清空画布<br>                    context.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, perCanvas.width, pdfHeight);<br>                    context.fillStyle = &#x27;#fff&#x27;;<br>                    context.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, perCanvas.width, pdfHeight);<br>                    // 绘制当前切割区域的图片<br>                    context.drawImage(img, <span class="hljs-number">0</span>, startY, perCanvas.width, perHeight, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, perCanvas.width, perHeight);<br>                    const perCanvasData = perCanvas.toDataURL();<br>                    pdf.addImage( perCanvasData , &#x27;JPEG&#x27;, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>,perCanvas.width,perCanvas.height);<br>                    if(i &lt; splitCount - <span class="hljs-number">1</span>) pdf.addPage();<br>                &#125;;<br>                pdf.save();<br>            &#125;, <span class="hljs-number">1000</span>)<br>        &#125;)<br>    &#125;,<br>    //将base64转换为文件..<br>    dataURLtoFile(dataurl, filename) &#123;<br>        var arr = dataurl.split(&#x27;,&#x27;), mime = arr[<span class="hljs-number">0</span>].match(/:(.*?);/)[<span class="hljs-number">1</span>],<br>            bstr = atob(arr[<span class="hljs-number">1</span>]), n = bstr.length, u8arr = new Uint8Array(n);<br>        while (n--) &#123;<br>            u8arr[n] = bstr.charCodeAt(n);<br>        &#125;<br>        return new File([u8arr], filename, &#123; type: mime &#125;);<br>    &#125;,<br>    // 文件上传 （这里使用的是原生ajax上传，可以使用其他方式 axios）<br>    upFile(file )&#123;<br>        var formData = new FormData();<br>        formData.append(&#x27;file&#x27;, file);<br>        var xhr = new XMLHttpRequest();<br>        xhr.open(&#x27;POST&#x27;, &quot;http://<span class="hljs-number">192.168</span>.<span class="hljs-number">0.39</span>:<span class="hljs-number">9110</span>/sys/xzfy/upload&quot;, true);<br>        xhr.onload = function() &#123;<br>        if (this.status == <span class="hljs-number">200</span>) &#123;<br>            var resJson = JSON.parse(xhr.responseText);<br>            console.log(resJson.msg);<br>        &#125; else &#123;<br>            console.error(&#x27;Error uploading file&#x27;);<br>        &#125;<br>        &#125;;<br>        xhr.send(formData);<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">这种方法需要注意分页地方内容切割问题</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>threeJs 基础使用</title>
    <link href="/2023/12/24/three.js%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/24/three.js%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>three.js每个月都会有新版本，使用需要对应版本对应文档，避免api冲突。<br>threejs官方文件包所有版本：<a href="https://github.com/mrdoob/three.js/releases">https://github.com/mrdoob/three.js/releases</a> （下载想要的版本包，包内有对应的文档）<br>Threejs中文网(电子书课件)：<a href="http://www.webgl3d.cn/">www.webgl3d.cn</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">three.js-文件包<br>...<br>└───docs——Three.js API文档文件<br>    │───index.html——打开该文件，本地离线方式预览threejs文档<br>└───examples——大量的3D案例，是你平时开发参考学习的最佳资源<br>    │───.html——各种3D案例<br>...    <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">这里是在vue项目中引入<br>// 比如安装148版本<br>npm install three@0.148.0 --save<br>// 引入three.js<br>import * as THREE from <span class="hljs-string">&#x27;three&#x27;</span>;<br></code></pre></td></tr></table></figure><p class="note note-primary">也可以html引入js进行使用：http://www.webgl3d.cn/pages/cd35b2/</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>three分为 场景Scene、相机Camera、渲染器Renderer三个基本概念。</p><p>生成一个基础模型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>    &lt;div class=<span class="hljs-string">&quot;homeView&quot;</span>&gt;<br>        &lt;div <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;webgl&quot;</span> &gt;&lt;/div&gt;<br>    &lt;/div&gt;  <br>&lt;/template&gt;<br>......<br><span class="hljs-function"><span class="hljs-title">mounted</span></span>()&#123;<br>        // 创建3D场景对象Scene<br>        const scene = new THREE.Scene();<br>        //创建一个长方体几何对象Geometry<br>        const geometry = new THREE.BoxGeometry(100, 100, 100); <br>        //创建一个材质对象Material<br>        const material = new THREE.MeshBasicMaterial(&#123;<br>            color: 0x0000ff, //设置材质颜色<br>        &#125;); <br>        // 两个参数分别为几何体geometry、材质material<br>        const mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh<br>        //设置网格模型在三维空间中的位置坐标，默认是坐标原点<br>        mesh.position.set(0,0,0);<br>        scene.add(mesh); <br>        // width和height用来设置Three.js输出的Canvas画布尺寸(像素px)<br>        const width = 800; //宽度<br>        const height = 500; //高度<br>        // 实例化一个透视投影相机对象<br>        // PerspectiveCamera( fov, aspect, near, far )<br>        // fov相机视锥体竖直方向视野角度50<br>        // aspect相机视锥体水平方向和竖直方向长度比，一般设置为Canvas画布宽高比width / height1<br>        // near相机视锥体近裁截面相对相机距离0.1<br>        // far相机视锥体远裁截面相对相机距离，far-near构成了视锥体高度方向2000<br>        const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);<br>        //相机在Three.js三维坐标系中的位置<br>        // 根据需要设置相机位置具体值<br>        camera.position.set(200, 200, 200); <br>        camera.lookAt(mesh.position);//指向mesh对应的位置<br>        // 创建渲染器对象<br>        const renderer = new THREE.WebGLRenderer();<br>        renderer.setSize(width, height); //设置three.js渲染区域的尺寸(像素px)<br>        renderer.render(scene, camera); //执行渲染操作<br>        document.getElementById(<span class="hljs-string">&#x27;webgl&#x27;</span>).appendChild(renderer.domElement);<br>    &#125;<br></code></pre></td></tr></table></figure><p>可添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">// AxesHelper：辅助观察的坐标系<br>// three.js坐标轴颜色红R、绿G、蓝B分别对应坐标系的x、y、z轴，对于three.js的3D坐标系默认y轴朝上。<br>const axesHelper = new THREE.AxesHelper(150);<br>scene.add(axesHelper);<br><br>const material = new THREE.MeshBasicMaterial(&#123;<br>    color: 0x0000ff, //设置材质颜色<br>    transparent:<span class="hljs-literal">true</span>,//开启透明<br>    opacity:0.5,//设置透明度<br>&#125;); <br></code></pre></td></tr></table></figure><h2 id="常见几何体"><a href="#常见几何体" class="headerlink" title="常见几何体"></a>常见几何体</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">//BoxGeometry：长方体<br>const geometry = new THREE.BoxGeometry(100, 100, 100);<br>// SphereGeometry：球体<br>const geometry = new THREE.SphereGeometry(50);<br>// CylinderGeometry：圆柱<br>const geometry = new THREE.CylinderGeometry(50,50,100);<br>// PlaneGeometry：矩形平面<br>const geometry = new THREE.PlaneGeometry(100,50);<br>// CircleGeometry：圆形平面<br>const geometry = new THREE.CircleGeometry(50);<br></code></pre></td></tr></table></figure><p class="note note-primary">    几何体是 矩形平面PlaneGeometry，圆形平面CircleGeometry时默认单面可见，如果想设置双面可见，材质加上side: THREE.DoubleSide属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">new THREE.MeshBasicMaterial(&#123;<br>    side: THREE.FrontSide, //默认只有正面可见<br>    side: THREE.DoubleSide, //两面可见<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">//MeshBasicMaterial不受光照影响<br>const material = new THREE.MeshBasicMaterial(); //基础<br><br>//MeshLambertMaterial受光照影响<br>const material = new THREE.MeshLambertMaterial(); //漫反射 （兰伯特网格材质）<br>const material = new THREE.MeshPhongMaterial(); //高光<br>const material = new THREE.MeshPhysicalMaterial(); //物理<br></code></pre></td></tr></table></figure><h3 id="MeshPhongMaterial对光照反射特点"><a href="#MeshPhongMaterial对光照反射特点" class="headerlink" title="MeshPhongMaterial对光照反射特点"></a>MeshPhongMaterial对光照反射特点</h3><p>MeshPhongMaterial和MeshLambertMaterial都会收到光照的影响区别在于，对光线反射方式有差异。<br>MeshPhongMaterial可以实现MeshLambertMaterial不能实现的高光反射效果。对于高光效果，你可以想象一下，你在太阳下面观察一辆车，你会发现在特定角度和位置，你可以看到车表面某个局部区域非常高亮。</p><h3 id="镜面反射与漫反射"><a href="#镜面反射与漫反射" class="headerlink" title="镜面反射与漫反射"></a>镜面反射与漫反射</h3><p>MeshPhongMaterial可以提供一个镜面反射效果,可以类比你生活中拿一面镜子，放在太阳光下，调整角度，可以把太阳光反射到其它地方，如果反射光对着眼睛，也就是反射光线和视线平行的时候，会非常刺眼。</p><p>MeshLambertMaterial对应的Mesh受到光线照射，没有镜面反射的效果，只是一个漫反射，也就是光线向四周反射。</p><h3 id="通过MeshPhongMaterial的高光亮度-shininess属性-specular属性-可以控制高光反射效果。"><a href="#通过MeshPhongMaterial的高光亮度-shininess属性-specular属性-可以控制高光反射效果。" class="headerlink" title="通过MeshPhongMaterial的高光亮度.shininess属性 .specular属性,可以控制高光反射效果。"></a>通过MeshPhongMaterial的高光亮度.shininess属性 .specular属性,可以控制高光反射效果。</h3><p>const material &#x3D; new THREE.MeshPhongMaterial({<br>    color: 0xff0000,<br>    shininess: 20, &#x2F;&#x2F;高光部分的亮度，默认30<br>    specular: 0x444444, &#x2F;&#x2F;高光部分的颜色<br>});</p><h2 id="渲染器"><a href="#渲染器" class="headerlink" title="渲染器"></a>渲染器</h2><h3 id="设置渲染器锯齿属性"><a href="#设置渲染器锯齿属性" class="headerlink" title="设置渲染器锯齿属性"></a>设置渲染器锯齿属性</h3><p>也就是抗锯齿，开~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">const renderer = new THREE.WebGLRenderer(&#123;<br>  antialias:<span class="hljs-literal">true</span>,<br>&#125;);<br><br>renderer.antialias = <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><h3 id="设置设备像素比"><a href="#设置设备像素比" class="headerlink" title="设置设备像素比"></a>设置设备像素比</h3><p>不设置硬件像素比会导致渲染模糊，除非像素比是1。<br>用window的属性获取硬件像素比，three渲染器设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 获取你屏幕对应的设备像素比.devicePixelRatio告诉threejs,以免渲染模糊问题<br>renderer.setPixelRatio(window.devicePixelRatio);<br></code></pre></td></tr></table></figure><h3 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">renderer.setClearColor(0x444444, 1); //设置背景颜色<br></code></pre></td></tr></table></figure><h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><p>光源<br>Three.js提供了多种模拟生活中光源的API，文档搜索关键词light就可以看到。<br>环境光 AmbientLight<br>点光源  PointLight<br>聚光灯光源  SpotLight<br>平行光  DirectionalLight</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 光源<br>//点光源：两个参数分别表示光源颜色和光照强度<br>// 参数1：0xffffff是纯白光,表示光源颜色<br>// 参数2：1.0,表示光照强度，可以根据需要调整<br>const pointLight = new THREE.PointLight(0xffffff, 3.0);<br>// // 可以直接操作光源强度<br>// pointLight.intensity = 1.0;//光照强度<br>pointLight.decay = 0.0;//设置光源不随距离衰减 （默认值2.0)<br>//点光源位置<br>pointLight.position.set(200, 350, 300);<br>scene.add(pointLight); //点光源添加到场景中<br><br>//环境光:没有特定方向，整体改变场景的光照明暗<br>const ambient = new THREE.AmbientLight(0xffffff, 0.4);<br>scene.add(ambient);<br><br>// 平行光<br>const directionalLight = new THREE.DirectionalLight(0xffffff, 1);<br>// 设置光源的方向：通过光源position属性和目标指向对象的position属性计算<br>directionalLight.position.set(80, 100, 50);<br>// 方向光指向对象网格模型mesh，可以不设置，默认的位置是0,0,0<br>directionalLight.target = mesh;<br>scene.add(directionalLight);<br>// DirectionalLightHelper：可视化平行光<br>const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5,0xff0000);<br>scene.add(dirLightHelper);<br><br></code></pre></td></tr></table></figure><h2 id="循环渲染-requestAnimationFrame"><a href="#循环渲染-requestAnimationFrame" class="headerlink" title="循环渲染 requestAnimationFrame"></a>循环渲染 requestAnimationFrame</h2><p>我们的确可以用 setInterval，但是，requestAnimationFrame 有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">const scene = new THREE.Scene(); //场景<br>const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 ); //相机<br><br>const renderer = new THREE.WebGLRenderer(); //渲染器<br>renderer.setSize( window.innerWidth, window.innerHeight ); //设置three.js渲染区域的尺寸(像素px)<br>document.body.appendChild( renderer.domElement ); //渲染器标签对象，添加到html body节点中<br><br>const geometry = new THREE.BoxGeometry( 1, 1, 1 ); //几何对象<br>const material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );//材质<br>const cube = new THREE.Mesh( geometry, material ); //网格模型对象<br>scene.add( cube ); <br><br>camera.position.z = 5;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">animate</span></span>() &#123;<br>    requestAnimationFrame( animate ); //循环渲染<br><br>    cube.rotation.x += 0.01;<br>    cube.rotation.y += 0.01;<br><br>    renderer.render( scene, camera );<br>&#125;<br><br><span class="hljs-keyword">if</span> ( WebGL.isWebGLAvailable() ) &#123; //判断浏览器是否支持webGL,需要引入js文件 import WebGL from <span class="hljs-string">&#x27;@/utils/WebGL.js&#x27;</span>; 地址：https://github.com/mrdoob/three.js/blob/master/examples/jsm/capabilities/WebGL.js<br>    animate();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    const warning = WebGL.getWebGLErrorMessage();<br>    console.log(warning);<br>    document.getElementById( <span class="hljs-string">&#x27;container&#x27;</span> ).appendChild( warning );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环渲染查看帧率"><a href="#循环渲染查看帧率" class="headerlink" title="循环渲染查看帧率"></a>循环渲染查看帧率</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 渲染循环<br>// requestAnimationFrame实现周期性循环执行<br>// requestAnimationFrame默认每秒钟执行60次，但不一定能做到，要看代码的性能<br>const clock = new THREE.Clock();<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">render</span></span>() &#123;<br>    const spt = clock.getDelta()*1000;//毫秒<br>    console.log(<span class="hljs-string">&#x27;两帧渲染时间间隔(毫秒)&#x27;</span>,spt);<br>    console.log(<span class="hljs-string">&#x27;帧率FPS&#x27;</span>,1000/spt);<br>    renderer.render(scene, camera); //执行渲染操作<br>    mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度<br>    requestAnimationFrame(render);//请求再次执行渲染函数render，渲染下一帧<br>&#125;<br>render();<br></code></pre></td></tr></table></figure><h2 id="查看性能，stats性能监视器-查看帧率"><a href="#查看性能，stats性能监视器-查看帧率" class="headerlink" title="查看性能，stats性能监视器 查看帧率"></a>查看性能，stats性能监视器 查看帧率</h2><p>一般场景越复杂往往渲染性能越低，也就是每秒钟执行.render()的次数越低。<br>通过stats.js库可以查看three.js当前的渲染性能，具体说就是计算three.js的渲染帧率(FPS),所谓渲染帧率(FPS)，简单说就是three.js每秒钟完成的渲染次数，一般渲染达到每秒钟60次为最佳状态。<br>stats.js下载链接：<a href="https://github.com/mrdoob/stats.js">https://github.com/mrdoob/stats.js</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">//引入性能监视器stats.js<br>import Stats from <span class="hljs-string">&#x27;three/addons/libs/stats.module.js&#x27;</span>;<br><br>......<br>//创建stats对象<br>const stats = new Stats();<br>// stats.domElement显示：渲染帧率  刷新频率,一秒渲染次数 <br>stats.setMode(0);//默认模式<br>//stats.domElement显示：渲染周期 渲染一帧多长时间(单位：毫秒ms)<br>//stats.setMode(1);<br><br>//stats.domElement:web页面上输出计算结果,一个div元素，<br>document.body.appendChild(stats.domElement);<br>// 渲染函数<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">render</span></span>() &#123;<br>    //requestAnimationFrame循环调用的函数中调用方法update(),来刷新时间<br>    stats.update();<br>    mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度<br>    renderer.render(scene, camera); //执行渲染操作<br>    requestAnimationFrame(render); //请求再次执行渲染函数render，渲染下一帧<br>&#125;<br>render();<br><br></code></pre></td></tr></table></figure><h2 id="相机控件（拖动）"><a href="#相机控件（拖动）" class="headerlink" title="相机控件（拖动）"></a>相机控件（拖动）</h2><p>创建好模型后添加监听实现，需要引入扩展组件<br>旋转：拖动鼠标左键<br>缩放：滚动鼠标中键<br>平移：拖动鼠标右键<br><span class="label label-primary">OrbitControls本质上就是改变相机的参数</span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">//引入<br>import &#123; OrbitControls &#125; from <span class="hljs-string">&#x27;three/addons/controls/OrbitControls.js&#x27;</span>;<br>......<br>// 设置相机控件轨道控制器OrbitControls<br>const controls = new OrbitControls(camera, renderer.domElement);<br>console.log(OrbitControls);<br>// 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景<br>controls.addEventListener(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    renderer.render(scene, camera); //执行渲染操作<br>&#125;); //监听鼠标、键盘事件<br></code></pre></td></tr></table></figure><h2 id="响应式画布"><a href="#响应式画布" class="headerlink" title="响应式画布"></a>响应式画布</h2><p>&#x2F;&#x2F; onresize 事件会在窗口被调整大小时发生<br>window.onresize &#x3D; function () {<br>    &#x2F;&#x2F; 重置渲染器输出画布canvas尺寸<br>    renderer.setSize(window.innerWidth, window.innerHeight);<br>    &#x2F;&#x2F; 全屏情况下：设置观察范围长宽比aspect为窗口宽高比<br>    camera.aspect &#x3D; window.innerWidth &#x2F; window.innerHeight;<br>    &#x2F;&#x2F; 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix<br>    &#x2F;&#x2F; 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)<br>    &#x2F;&#x2F; 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵<br>    camera.updateProjectionMatrix();<br>};</p><h2 id="camera-lookAt-设置注意"><a href="#camera-lookAt-设置注意" class="headerlink" title="camera.lookAt 设置注意"></a>camera.lookAt 设置注意</h2><p>注意相机控件OrbitControls会影响lookAt设置，注意手动设置OrbitControls的目标参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">......<br>camera.lookAt(1000, 0, 1000);<br>......<br>/ 设置相机控件轨道控制器OrbitControls<br>const controls = new OrbitControls(camera, renderer.domElement);<br>// 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景<br>controls.target.set(1000, 0, 1000);<br>controls.update();//update()函数内会执行camera.lookAt(controls.targe)<br>controls.addEventListener(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    renderer.render(scene, camera); //执行渲染操作<br>&#125;);//监听鼠标、键盘事件<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>持续更新中。。。</p>]]></content>
    
    
    <categories>
      
      <category>threeJs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>threeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack和Vite打包工具的具体工作流程以及区别</title>
    <link href="/2023/06/25/vite%20Webpack%E5%92%8CVite/"/>
    <url>/2023/06/25/vite%20Webpack%E5%92%8CVite/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack和vite工作流程图"><a href="#webpack和vite工作流程图" class="headerlink" title="webpack和vite工作流程图"></a>webpack和vite工作流程图</h1><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack会对整个应用程序进行依赖关系图构建。而这也会导致一个不可避免的情况，使用Webpack启动应用程序的服务器，会花费比较长的时间——一些大型应用程序可能需要10分钟以上。<br>此时你心里可能已经在抓狂了，为什么会这么费时间？那就让我们一起看看基于 Webpack 包的整个工作流。<br><img src="/images/webpack-vite1.png" alt="图片" title=" "></p><h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p>Vite根据JavaScript生态系统中最近所做的两项改进——浏览器中ES模块的可用性，以及esbuild等本机捆绑工具的编译功能，为开发者提供更加强大的支持。<br>Vite的核心理念是非捆绑式开发建设。<br>浏览器中ES模块的可用性允许您在浏览器上运行JavaScript应用程序，而无需将它们捆绑在一起。<br>Vite的核心思想很简单：当浏览器请求时，使用ES模块进行转换并提供一段应用程序代码。<br>开始开发后，Vite将首先将JavaScript模块分为两类：依赖模块和应用程序模块。<br>依赖模块是从node_modules文件夹导入的JavaScript模块。这些模块将使用esbuild进行处理和绑定，esbuild是用Go编写的JavaScript绑定器，执行速度比Webpack快10到100倍。<br>应用程序模块是为应用程序编写的模块，通常涉及特定于库的扩展，如：jsx &#x2F; vue 或 scss文件。<br>虽然基于捆绑程序的工作流（如Webpack）必须在单个浏览器请求之前处理整个JavaScript模块，但Vite仅在单个浏览器请求之前处理依赖模块。<br><img src="/images/webpack-vite2.png" alt="图片" title=" "></p><p class="note note-primary">就好像我们去一家餐厅吃饭，Webpack的后厨一口气做完所有的饭，然后一道道为你上菜；而Vite的厨子手脚麻利，很快做完一道菜就上一道菜。这就是vite构建项目体验上感觉速度会快的原因。webpack拥有着高用户群体，但随着时间推移 vite不断完善生态，可能会后来者居上了。</p><h1 id="vite优点"><a href="#vite优点" class="headerlink" title="vite优点:"></a>vite优点:</h1><p>1.webpack服务器启动速度比vite慢<br>2.由于vite启动的时候不需要打包，也就无需分析模块依赖、编译，所以启动速度非常快。当浏览器请求需要的模块时，再对模块进行编译，这种按需动态编译的模式，极大缩短了编译时间，当项目越大，文件越多时，vite的开发时优势越明显<br>3.vite热更新比webpack快<br>4.vite在HRM方面，当某个模块内容改变时，让浏览器去重新请求该模块即可，而不是像webpack重新将该模块的所有依赖重新编译,<br>5.vite使用esbuild(Go 编) 预构建依赖，而webpack基于nodejs,比node快 10-100 倍</p><h1 id="vite缺点"><a href="#vite缺点" class="headerlink" title="vite缺点:"></a>vite缺点:</h1><p>1.生态不及webpack，加载器、插件不够主富<br>2.打包到生产环境时，vite使用传统的rolup进行打包，生产环境esbuild构建对于CSs和代码分割不够友好。所以，vite的优势是体现在开发阶段<br>没被大规模重度使用，会隐藏一些问题<br>项目的开发浏览器要支持esmodule，而目不能识别commonis语法<br>3.webpack和vite的工作流程及区别（通俗解释）<br>webpack和vite的工作流程：<br>webpack打包是先分析项目路由然后分析路由相对应的模块，然后全部打包，再调用服务器，所以编译速度较慢，没有用到的模块也全部打包了。<br>vite是先调用服务器，直接准备好，然后看你请求的是哪一个路由然后只去打包哪一个路由所对应的模块，没有请求的路由就不去打包，做到了按需编译打包，不再等待整个应用编译完成，提高了编译运行时速度。</p>]]></content>
    
    
    <categories>
      
      <category>Vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue 基础-使用配置</title>
    <link href="/2022/07/02/vue%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/07/02/vue%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="配置vue2"><a href="#配置vue2" class="headerlink" title="配置vue2"></a>配置vue2</h1><p>当使用vue-cli 创建vue项目后为了更加高效的展开工作，下面让我们配置一些东西。</p><h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><p>vue 不得不使用axios，axios虽然本身基于ajax进行的封装，他的基本用法也是比较方便，但在项目体量大的时候，还是需要我们根据情况进行二次封装，好处是更清晰的模块化，功能化，便于统一管理代码。</p><p>1.src目录下创建 utils文件夹，这里用于存放一些配置文件。<br>2.在其内创建http.js，做axios的基础配置功能:<br>&emsp;&emsp;a.配置了请求 响应拦截器来做登录验证跳转<br>&emsp;&emsp;b.请求超时，断网错误处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs bash">//http.js<br><br>import axios from <span class="hljs-string">&#x27;axios&#x27;</span><br>import router from <span class="hljs-string">&#x27;../router&#x27;</span><br>import store from <span class="hljs-string">&#x27;../store&#x27;</span><br>/** <br> * 提示函数<br> * 显示一秒后关闭、禁止点击蒙层<br> */<br>const tip = msg =&gt; &#123;<br>    alert(msg)<br>&#125;<br>/** <br> * 跳转登录页<br> * 携带当前页面路由，以其在登录页面完成登录后返回当前页面<br> */<br>const toLogin = () =&gt; &#123;<br>    router.replace(&#123;<br>        path: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>        query: &#123;<br>            redirect: router.currentRoute.fullPath<br>        &#125;<br>    &#125;)<br>&#125;<br><br>/** <br> * 请求失败后的错误统一处理<br>* @param &#123;Number&#125; status 请求失败的状态码<br> */<br>const errorHandle = (status, other = <span class="hljs-string">&#x27;&#x27;</span>) =&gt; &#123;  <br>    alert(status)<br>    // 状态码判断<br>    switch (status) &#123;<br>        // 401: 未登录状态，跳转登录页<br>        <span class="hljs-keyword">case</span> 401:<br>            toLogin();<br>            <span class="hljs-built_in">break</span>;<br>        // 403 token过期，清除token并跳转登录页<br>        <span class="hljs-keyword">case</span> 403:<br>            tip(<span class="hljs-string">&#x27;登录过期，请重新登录&#x27;</span>);<br>            localStorage.removeItem(<span class="hljs-string">&#x27;token&#x27;</span>);<br>            store.commit(<span class="hljs-string">&#x27;login&#x27;</span>, null);<br>            setTimeout(() =&gt; &#123;<br>                toLogin();<br>            &#125;, <span class="hljs-number">1000</span>);<br>            break;<br>        // <span class="hljs-number">404</span>请求不存在<br>        case <span class="hljs-number">404</span>:<br>            tip(&#x27;请求的资源不存在&#x27;);<br>            break;<br>        default:<br>            // console.log(other);<br>    &#125;<br>&#125;<br>// 创建axios实例<br>var instance = axios.create(&#123;<br>    timeout: <span class="hljs-number">1000</span> * <span class="hljs-number">12</span><br>&#125;)<br>// 设置post请求头<br>instance.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;;<br>/** <br> * 请求拦截器<br> * 每次请求前，如果存在token则在请求头中携带token<br>*/<br>instance.interceptors.request.use(<br>    config =&gt; &#123;<br>        // 在每次请求之前是否断网状态恢复默认连接正常<br>        store.commit(&#x27;changeNetwork&#x27;, true); <br><br>        // 登录流程控制中，根据本地是否存在token判断用户的登录情况<br>        // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token<br>        // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码<br>        // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。<br>        const token = store.state.token;<br>        token &amp;&amp; (config.headers.Authorization = token);<br>        return config;<br>    &#125;,<br>    error =&gt; Promise.error(error)<br>)<br>// 响应拦截器<br>instance.interceptors.response.use(<br>    // 请求成功<br>    // res =&gt; res.status === <span class="hljs-number">200</span> ? Promise.resolve(res) : Promise.reject(res),<br>    (res)=&gt;&#123;    <br>        // 响应成功操作<br>        return res.status === <span class="hljs-number">200</span> ? Promise.resolve(res) : Promise.reject(res)<br>    &#125;,<br>    // 请求失败<br>    error =&gt; &#123;<br>        const &#123; response &#125; = error;<br>        if (response) &#123;<br>            // 请求已发出，但是不在<span class="hljs-number">2</span>xx的范围<br>            errorHandle(response.status, response.data.message);<br>            return Promise.reject(response);<br>        &#125; else &#123;<br>            // 处理断网的情况<br>            // eg:请求超时或断网时，更新state的network状态<br>            // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏<br>            // 关于断网组件中的刷新重新获取数据，会在断网组件中说明<br>            store.commit(&#x27;changeNetwork&#x27;, false);<br>        &#125;<br>    &#125;<br>)<br><br>export default instance;<br></code></pre></td></tr></table></figure><p>3.src目录下创建文件夹api，这里用于存放一些接口模块文件。<br>4.api文件夹内创建index.js (api接口的统一出口)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">/** <br> * api接口的统一出口<br> */<br>import article from <span class="hljs-string">&#x27;@/api/article&#x27;</span>; // 文章模块接口<br>// 其他模块的接口……<br><br>// 导出接口<br><span class="hljs-built_in">export</span> default &#123;<br>    article,<br>    // ……<br>&#125;<br></code></pre></td></tr></table></figure><p>5.api文件夹内创建config.js (接口域名的管理)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">/** <br> * 接口域名的管理<br> */<br> const config = &#123;<br>    apiUrl: <span class="hljs-string">&#x27;http://hl.xxxx.gov.cn:5009&#x27;</span>,<br>    // searchUrl: <span class="hljs-string">&#x27;https://search.domain.com/api/v1&#x27;</span> //可配置多个请求地址<br>&#125;<br><br><span class="hljs-built_in">export</span> default config;<br></code></pre></td></tr></table></figure><p>6.api文件夹内创建article.js(文章接口模块，这个文件可以是多个，例如用户接口模块等)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">/**<br> * article模块接口列表<br> */<br>import config from <span class="hljs-string">&#x27;./config&#x27;</span><br>import axios from <span class="hljs-string">&#x27;@/utils/http&#x27;</span><br>// import qs from <span class="hljs-string">&#x27;qs&#x27;</span><br><br>const article = &#123;<br>    //测试接口<br>    articleList(params) &#123;<br>        <span class="hljs-built_in">return</span> axios.post(`<span class="hljs-variable">$&#123;config.apiUrl&#125;</span>/api/institution/getCount`, params);<br>    &#125;,<br>    // // 新闻详情<br>    // articleDetail(<span class="hljs-built_in">id</span>, params) &#123;<br>    //     <span class="hljs-built_in">return</span> axios.get(`<span class="hljs-variable">$&#123;config.apiUrl&#125;</span>/topics/<span class="hljs-variable">$&#123;id&#125;</span>`, &#123; params &#125;);<br>    // &#125;,<br>&#125;<br><br><span class="hljs-built_in">export</span> default article;<br><br></code></pre></td></tr></table></figure><p>7.最后挂载到vue上，打开main.js</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">import api from <span class="hljs-string">&#x27;./api&#x27;</span> // 导入api接口<br>Vue.prototype.<span class="hljs-variable">$api</span> = api // 将api挂载到vue的原型上<br></code></pre></td></tr></table></figure><p>8.使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 调取文章接口<br>this.<span class="hljs-variable">$api</span>.article.articleList(&#123;dacq:xx&#125;);<br></code></pre></td></tr></table></figure><h2 id="请求超时，登录状态"><a href="#请求超时，登录状态" class="headerlink" title="请求超时，登录状态"></a>请求超时，登录状态</h2><p>这里用到了vuex来实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">//store<br>import Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br>import Vuex from <span class="hljs-string">&#x27;vuex&#x27;</span><br>Vue.use(Vuex)<br><br><span class="hljs-built_in">export</span> default new Vuex.Store(&#123;<br>    state: &#123;<br>        network: <span class="hljs-literal">true</span>, //网络状态 <span class="hljs-literal">false</span> 断网<br>        hasLogin: <span class="hljs-literal">true</span>, //登录状态 <span class="hljs-literal">false</span> 未登录<br>        token: <span class="hljs-string">&#x27;&#x27;</span> //登录后存储token<br>    &#125;,<br>    mutations: &#123;<br>        //更新网络状态<br>        changeNetwork(state, value) &#123;<br>            state.network = value;<br>        &#125;,<br>        //登录<br>        login(state, provider) &#123;<br>            state.hasLogin = <span class="hljs-literal">true</span>;<br>            state.token = provider.token;<br>            localStorage.setItem(<span class="hljs-string">&#x27;token&#x27;</span>, provider.token);<br>        &#125;,<br>        //退出登录<br>        <span class="hljs-built_in">logout</span>(state) &#123;<br>            state.hasLogin = <span class="hljs-literal">false</span>;<br>            state.token = <span class="hljs-string">&#x27;&#x27;</span>;<br>            localStorage.removeItem(<span class="hljs-string">&#x27;token&#x27;</span>);<br>        &#125;<br>    &#125;,<br>    actions: &#123;<br>    &#125;,<br>    modules: &#123;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">//app.vue<br>&lt;template&gt;<br>  &lt;div <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>    &lt;div v-if=<span class="hljs-string">&quot;!network&quot;</span>&gt;<br>      &lt;h1&gt;网络出现了点问题...&lt;/h1&gt;<br>      &lt;button @click=<span class="hljs-string">&quot;onRefresh&quot;</span>&gt;点击刷新&lt;/button&gt;<br>    &lt;/div&gt;<br>    &lt;router-view&gt;&lt;/router-view&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; mapState &#125; from <span class="hljs-string">&quot;vuex&quot;</span>;<br><span class="hljs-built_in">export</span> default &#123;<br>  name: <span class="hljs-string">&quot;App&quot;</span>,<br>  computed: &#123;<br>    ...mapState([<span class="hljs-string">&quot;network&quot;</span>]),<br>  &#125;,<br>  methods: &#123;<br>    // 通过跳转一个空页面再返回的方式来实现刷新当前页面数据的目的<br>    <span class="hljs-function"><span class="hljs-title">onRefresh</span></span>() &#123;<br>      this.<span class="hljs-variable">$router</span>.replace(<span class="hljs-string">&quot;/refresh&quot;</span>);<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br><span class="hljs-comment">#app &#123;</span><br>  font-family: <span class="hljs-string">&quot;Avenir&quot;</span>, Helvetica, Arial, sans-serif;<br>  -webkit-font-smoothing: antialiased;<br>  -moz-osx-font-smoothing: grayscale;<br>  text-align: center;<br>  color: <span class="hljs-comment">#2c3e50;</span><br>  margin-top: 60px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">//refresh.vue<br>&lt;template&gt;<br>  &lt;div&gt;&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br><span class="hljs-built_in">export</span> default &#123;<br>    // 断网页面跳转<br>  beforeRouteEnter(to, from, next) &#123;<br>    next((vm) =&gt; &#123;<br>      vm.<span class="hljs-variable">$router</span>.replace(from.fullPath);<br>    &#125;);<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>思路：axios拦截器在请求超时时，改变vuex状态，vue的router-view不显示，显示超时样式。点击刷新按钮即跳转refresh.vue，再做跳转回页面做刷新</p><h2 id="配置全局css"><a href="#配置全局css" class="headerlink" title="配置全局css"></a>配置全局css</h2><p>可以在src根目录下创建文件 main.less</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs bash">// main.less 全局css<br>* &#123;<br>    box-sizing: border-box;<br>&#125;<br>body &#123;<br>    -moz-user-select: none;<br>    -webkit-user-select: none;<br>    -ms-user-select: none;<br>    -khtml-user-select: none;<br>    user-select: none;<br>&#125;<br>.afafaf &#123;<br>    color: <span class="hljs-comment">#afafaf;</span><br>&#125;<br>.tooltip-color&#123;<br>    margin-left: 5px;<br>&#125;<br>.tooltip-color:before&#123;<br>    color: <span class="hljs-comment">#fcca5f;</span><br>    vertical-align: middle;<br><br>&#125;<br>.tooltip-color2:before&#123;<br>    color: <span class="hljs-comment">#409EFF;</span><br>    vertical-align: middle;<br>&#125;<br>// .el-radio__input.is-checked+.el-radio__label&#123;<br>//     vertical-align: middle;<br>// &#125;<br>.el-checkbox__label&#123;<br>    vertical-align: middle;<br>&#125;<br>.el-select&#123;<br>    width: 50%;<br>&#125;<br><br>body,<br>ul,<br>ol,<br>dl,<br><span class="hljs-built_in">dd</span>,<br>h1,<br>h2,<br>h3,<br>h4,<br>h5,<br>h6,<br>p,<br>form,<br>fieldset,<br>legend,<br>input,<br>textarea,<br><span class="hljs-keyword">select</span>,<br>button,<br>th,<br>td &#123;<br>    margin: 0;<br>    padding: 0;<br>&#125;<br><br>h1,<br>h2,<br>h3,<br>h4,<br>h5,<br>h6 &#123;<br>    font-size: 100%;<br>    font-weight: normal;<br>&#125;<br><br>table &#123;<br>    font-size: inherit;<br>&#125;<br><br>input,<br><span class="hljs-keyword">select</span> &#123;<br>    font-family: arial, helvetica, clean, sans-serif;<br>    font-size: 100%;<br>    font-size-adjust: none;<br>    font-stretch: normal;<br>    font-style: normal;<br>    font-variant: normal;<br>    font-weight: normal;<br>    line-height: normal;<br>&#125;<br><br>button &#123;<br>    overflow: visible;<br>&#125;<br><br>th,<br>em,<br>strong,<br>b,<br>address,<br>cite &#123;<br>    font-style: normal;<br>    font-weight: normal;<br>&#125;<br><br>li &#123;<br>    list-style-image: none;<br>    list-style-position: outside;<br>    list-style-type: none;<br>&#125;<br><br>img,<br>fieldset &#123;<br>    border: 0 none;<br>&#125;<br><br>ins &#123;<br>    text-decoration: none;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>引入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// main.js<br>import <span class="hljs-string">&#x27;./main.less&#x27;</span><br></code></pre></td></tr></table></figure><p>报错 Can’t resolve ‘less-loader’<br>安装less </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">安装<br>npm install less less-loader --save-dev<br><br>lessc -v //查看版本<br></code></pre></td></tr></table></figure><p class="note note-primary">如有其他配置会继续更新~</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3 Composition API 和 Vue Mixins (1)</title>
    <link href="/2022/05/28/vue3%20Composition%20API%20%E5%92%8C%20Vue%20Mixins(1)/"/>
    <url>/2022/05/28/vue3%20Composition%20API%20%E5%92%8C%20Vue%20Mixins(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h2><p>Vue组件之间共享代码<br>熟悉Vue 2，你可能已经使用了一个 mixin 来实现这个目的。但是新的Composition API，现在作为Vue 2的插件和Vue 3即将推出的一项功能，提供了一个更好的解决方案。</p><p>在这篇文章中，我们将看看Mixins的缺点，并看看Composition API是如何克服这些缺点，让Vue应用的可扩展性更强。</p><h2 id="Mixins简述"><a href="#Mixins简述" class="headerlink" title="Mixins简述"></a>Mixins简述</h2><p>让我们快速回顾一下mixins模式。</p><p>通常情况下，一个Vue组件是由一个JavaScript对象来定义的，这个JavaScript对象具有各种属性，代表着我们需要的功能，data, methods, computed等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">// MyComponent.js<br><span class="hljs-built_in">export</span> default &#123;<br>    data: () =&gt; (&#123;<br>        myDataProperty: null<br>    &#125;),<br>    methods: &#123;<br>        <span class="hljs-function"><span class="hljs-title">myMethod</span></span> () &#123; ... &#125;<br>    &#125;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们想在组件之间共享相同的属性时，我们可以将共同的属性提取到一个单独的模块中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">// MyMixin.js<br><span class="hljs-built_in">export</span> default &#123;<br>  data: () =&gt; (&#123;<br>    mySharedDataProperty: null<br>  &#125;),<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">mySharedMethod</span></span> () &#123; ... &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以通过将其分配给mixin config属性并将其添加到任何使用的组件中。在运行时，Vue将把组件的属性与任何添加的mixin合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">// ConsumingComponent.js<br>import MyMixin from <span class="hljs-string">&quot;./MyMixin.js&quot;</span>;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  mixins: [MyMixin],<br>  data: () =&gt; (&#123;<br>    myLocalDataProperty: null<br>  &#125;),<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">myLocalMethod</span></span> () &#123; ... &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个具体的例子中，运行时使用的组件定义是这样的。 可以看出mixin的组件属性(data、mthods..)都会分别进入了引入页面的相对位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> default &#123;<br>  data: () =&gt; (&#123;<br>    mySharedDataProperty: null<br>    myLocalDataProperty: null<br>  &#125;),<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">mySharedMethod</span></span> () &#123; ... &#125;,<br>    <span class="hljs-function"><span class="hljs-title">myLocalMethod</span></span> () &#123; ... &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mixins的缺点"><a href="#Mixins的缺点" class="headerlink" title="Mixins的缺点"></a>Mixins的缺点</h2><p>不清晰的数据来源：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。<br>命名空间冲突：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。<br>隐式的跨 mixin 交流：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。</p><h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p>我们看到mixin模式是如何在运行时合并两个对象的。如果它们都共享一个同名的属性，会发生什么？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">const mixin = &#123;<br>  data: () =&gt; (&#123;<br>    myProp: null<br>  &#125;)<br>&#125;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  mixins: [mixin],<br>  data: () =&gt; (&#123;<br>    // same name!<br>    myProp: null<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是合并策略发挥作用的地方。这是一组规则，用于决定当一个组件包含多个相同名称的选项时的情况。</p><p>Vue 组件的默认（但可选择配置）合并策略决定了本地选项将覆盖混合器选项。但也有例外。例如，如果我们有多个相同类型的生命周期钩子，那么这些钩子将被添加到钩子数组中，并且所有的钩子将被依次调用。</p><p>尽管我们不应该遇到任何实际的错误，但当我们在多个组件和混合体之间杂耍命名的属性时，写代码会变得越来越困难。尤其是当第三方的混合组件被添加为npm包时，这就更难了，因为它们的命名属性可能会引起冲突。</p><p>mixins 的缺点促进了 Composition API。来看看Composition API 如何运行。</p><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><p>组合式API的关键思想是，我们将组件的功能（如状态、方法、计算属性等）定义为对象属性，而不是将其定义为从新的设置函数中返回的JavaScript变量。</p><p>以这个经典的Vue 2组件为例，它定义了一个 “计数器 “功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">//Counter.vue<br><span class="hljs-built_in">export</span> default &#123;<br>  data: () =&gt; (&#123;<br>    count: 0<br>  &#125;),<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span></span>() &#123;<br>      this.count++;<br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">double</span></span> () &#123;<br>      <span class="hljs-built_in">return</span> this.count * 2;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是使用 Composition API 定义的完全相同的组件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">// Counter.vue<br>import &#123; ref, computed &#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span></span>() &#123;<br>    const count = ref(0);<br>    const double = computed(() =&gt; count * <span class="hljs-number">2</span>)<br>    function increment() &#123;<br>      count.value++;<br>    &#125;<br>    return &#123;<br>      count,<br>      double,<br>      increment<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先你会注意到我们导入了一个ref函数，这使得我们可以定义一个响应式变量，其功能与数据变量基本相同。计算函数也是一样的。</p><p>增量方法不是响应式的，所以它可以被声明为一个普通的JavaScript函数。注意，我们需要改变子属性值，才能改变count响应式变量的值。这是因为使用 ref 创建的响应式变量在传递过程中，需要将其作为对象来保留响应式变量。</p><p>一旦我们定义了这些功能，我们就从setup函数中返回这些功能。上面的两个组件在功能上没有什么区别。我们所做的就是使用替代API。</p><p class="note note-primary">Composition API将是Vue 3的核心功能，但你也可以在Vue 2中通过NPM插件@vue/composition-api使用它。</p><p>功能代码提取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">//useCounter.js<br>import &#123; ref, computed &#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-built_in">export</span> default <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>  const count = ref(0);<br>  const double = computed(() =&gt; count * <span class="hljs-number">2</span>)<br>  function increment() &#123;<br>    count.value++;<br>  &#125;<br>  return &#123;<br>    count,<br>    double,<br>    increment<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>功能代码重用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">// MyComponent.js<br>import useCounter from <span class="hljs-string">&quot;./useCounter.js&quot;</span>;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span></span>() &#123;<br>    const &#123; count, double, increment &#125; = useCounter();<br>    <span class="hljs-built_in">return</span> &#123;<br>      count,<br>      double,<br>      increment<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Composition-API优点"><a href="#Composition-API优点" class="headerlink" title="Composition API优点"></a>Composition API优点</h2><p>响应式 API：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。<br>生命周期钩子：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。<br>依赖注入：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>mixin模式表面上看起来很安全。然而，通过合并对象来共享代码，由于它给代码增加了脆弱性，并且掩盖了推理功能的能力，因此成为一种反模式。</p><p>Composition API 最聪明的地方在于，它允许 Vue 依靠原生 JavaScript 内置的保障措施来共享代码，比如将变量传递给函数，以及模块系统。</p><p>这是否意味着Composition API在各方面都比Vue的经典API优越？不是的，在大多数情况下，你可以坚持使用经典的API。但是，如果你打算重用代码，Composition API无疑是优越的。</p><p>本文参考: <a href="https://css-tricks.com/how-the-Vue-composition-api-replaces-vue-mixins/">https://css-tricks.com/how-the-Vue-composition-api-replaces-vue-mixins/</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
      <category>Composition API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3 基础使用</title>
    <link href="/2022/04/22/vue3%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/22/vue3%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3简介"><a href="#Vue3简介" class="headerlink" title="Vue3简介"></a>Vue3简介</h1><p>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）<br>github上的tags地址：<a href="https://github.com/vuejs/core/releases/tag/v3.0.0">Release v3.0.0 One Piece · vuejs&#x2F;core · GitHub</a></p><h1 id="Vue3优势"><a href="#Vue3优势" class="headerlink" title="Vue3优势"></a>Vue3优势</h1><h2 id="性能的提升"><a href="#性能的提升" class="headerlink" title="性能的提升"></a>性能的提升</h2><p>打包大小减少41%<br>初次渲染快55%, 更新渲染快133%<br>内存减少54%</p><h2 id="性能的提升-1"><a href="#性能的提升-1" class="headerlink" title="性能的提升"></a>性能的提升</h2><p>源码的升级<br>使用Proxy代替defineProperty实现响应式<br>重写虚拟DOM的实现和Tree-Shaking</p><h2 id="拥抱TypeScript"><a href="#拥抱TypeScript" class="headerlink" title="拥抱TypeScript"></a>拥抱TypeScript</h2><p>Vue3可以更好的支持TypeScript</p><h2 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h2><p>Composition API（组合API）<br>setup配置<br>ref与reactive<br>watch与watchEffect<br>provide与inject<br>……</p><h2 id="新的内置组件"><a href="#新的内置组件" class="headerlink" title="新的内置组件"></a>新的内置组件</h2><p>Fragment<br>Teleport<br>Suspense</p><h2 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h2><p>新的生命周期钩子<br>data 选项应始终被声明为一个函数<br>移除keyCode支持作为 v-on 的修饰符</p><h1 id="创建Vue3-0工程"><a href="#创建Vue3-0工程" class="headerlink" title="创建Vue3.0工程"></a>创建Vue3.0工程</h1><h2 id="使用-vue-cli-创建"><a href="#使用-vue-cli-创建" class="headerlink" title="使用 vue-cli 创建"></a>使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">创建一个项目 | Vue CLI</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span><br>vue --version<br><span class="hljs-comment">## 安装或者升级你的@vue/cli</span><br>npm install -g @vue/cli<br><span class="hljs-comment">## 创建</span><br>vue create vue_test<br><span class="hljs-comment">## 启动</span><br><span class="hljs-built_in">cd</span> vue_test<br>npm run serve<br></code></pre></td></tr></table></figure><h2 id="使用-vite-创建"><a href="#使用-vite-创建" class="headerlink" title="使用 vite 创建"></a>使用 vite 创建</h2><p><a href="/2023/06/25/vite%20Webpack%E5%92%8CVite/">webpack 和 vite 可移步</a><br>官方文档：<a href="https://cn.vuejs.org/guide/quick-start.html#vite">快速上手 | Vue.js</a><br>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a><br>什么是vite？—— 新一代前端构建工具。</p><p>优势如下：<br>    <ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li><li>传统构建 与 vite构建对比图</li></ul></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建工程</span><br>npm init vite-app &lt;project-name&gt;<br><span class="hljs-comment">## 进入工程目录</span><br><span class="hljs-built_in">cd</span> &lt;project-name&gt;<br><span class="hljs-comment">## 安装依赖</span><br>npm install<br><span class="hljs-comment">## 运行</span><br>npm run dev<br></code></pre></td></tr></table></figure><h2 id="常用-Composition-API"><a href="#常用-Composition-API" class="headerlink" title="常用 Composition API"></a>常用 Composition API</h2><p>官方文档: <a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html">组合式 API 常见问答 | Vue.js</a><br><a href="/2022/05/28/vue3%20Composition%20API%20%E5%92%8C%20Vue%20Mixins(1)/">Composition API 和 mixins 可移步</a></p><h3 id="1-setup"><a href="#1-setup" class="headerlink" title="1.setup"></a>1.setup</h3><p>理解：Vue3.0中一个新的配置项，值为一个函数。<br>setup是所有Composition API（组合API）“ 表演的舞台 ”。<br>组件中所用到的：数据、方法等等，均要配置在setup中。<br>setup函数的两种返回值：<br>&emsp;&emsp;若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）<br>&emsp;&emsp;若返回一个渲染函数：则可以自定义渲染内容。（了解）<br>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</p><p class="note note-warning">注意：尽量不要与Vue2.x配置混用，Vue2.x配置（data、methos、computed...）中可以访问到setup中的属性、方法。但在setup中不能访问到Vue2.x配置（data、methos、computed...）。如果有重名, setup优先。</p><h3 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h3><p>作用: 定义一个响应式的数据<br>语法: const xxx &#x3D; ref(initValue)</p><p>创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。<br>JS中操作数据： xxx.value<br>模板中读取数据: 不需要.value，直接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p class="note note-success">备注：接收的数据可以是：基本类型、也可以是对象类型。基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。</p><h3 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h3><p>作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）<br>语法：const 代理对象&#x3D; reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）</p><p>reactive定义的响应式数据是“深层次的”。<br>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</p><h3 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h3><h4 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h4><p>实现原理：<br>&emsp;&emsp;对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。<br>&emsp;&emsp;数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Object.defineProperty(data, <span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span></span> () &#123;&#125;, <br>    <span class="hljs-function"><span class="hljs-title">set</span></span> () &#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>存在问题：<br>&emsp;&emsp;新增属性、删除属性, 界面不会更新。<br>&emsp;&emsp;直接通过下标修改数组, 界面不会自动更新。</p><h4 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h4><p>实现原理:<br>&emsp;&emsp;通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。<br>&emsp;&emsp;通过Reflect（反射）: 对源对象的属性进行操作。</p><p>MDN文档中描述的Proxy与Reflect：<br>&emsp;&emsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy：Proxy - JavaScript | MDN</a><br>&emsp;&emsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect：Reflect - JavaScript | MDN</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">new Proxy(data, &#123;<br>    // 拦截读取属性值<br>    get (target, prop) &#123;<br>        <span class="hljs-built_in">return</span> Reflect.get(target, prop)<br>    &#125;,<br>    // 拦截设置属性值或添加新属性<br>    <span class="hljs-built_in">set</span> (target, prop, value) &#123;<br>        <span class="hljs-built_in">return</span> Reflect.<span class="hljs-built_in">set</span>(target, prop, value)<br>    &#125;,<br>    // 拦截删除属性<br>    deleteProperty (target, prop) &#123;<br>        <span class="hljs-built_in">return</span> Reflect.deleteProperty(target, prop)<br>    &#125;<br>&#125;)<br>proxy.name = <span class="hljs-string">&#x27;tom&#x27;</span> <br></code></pre></td></tr></table></figure><h3 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h3><p>从定义数据角度对比：<br>&emsp;&emsp;ref用来定义：基本类型数据。<br>&emsp;&emsp;reactive用来定义：对象（或数组）类型数据。</p><p class="note note-success">备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。</p><p>从原理角度对比：<br>&emsp;&emsp;ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。<br>&emsp;&emsp;reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。</p><p>从使用角度对比：<br>&emsp;&emsp;ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。<br>&emsp;&emsp;reactive定义的数据：操作数据与读取数据：均不需要.value。</p><h3 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h3><p>setup执行的时机<br>&emsp;&emsp;在beforeCreate之前执行一次，this是undefined。<br>setup的参数<br>&emsp;&emsp;props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。<br>&emsp;&emsp;context：上下文对象<br>&emsp;&emsp;attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。<br>&emsp;&emsp;slots: 收到的插槽内容, 相当于 this.$slots。<br>&emsp;&emsp;emit: 分发自定义事件的函数, 相当于 this.$emit。</p><h3 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h3><h4 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h4><p>与Vue2.x中computed配置功能一致<br>写法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">import &#123;computed&#125; from <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-function"><span class="hljs-title">setup</span></span>()&#123;<br>    ...<br>    //计算属性——简写<br>    <span class="hljs-built_in">let</span> fullName = computed(()=&gt;&#123;<br>        return person.firstName + &#x27;-&#x27; + person.lastName<br>    &#125;)<br>    //计算属性——完整<br>    let fullName = computed(&#123;<br>        get()&#123;<br>            return person.firstName + &#x27;-&#x27; + person.lastName<br>        &#125;,<br>        set(value)&#123;<br>            const nameArr = value.split(&#x27;-&#x27;)<br>            person.firstName = nameArr[<span class="hljs-number">0</span>]<br>            person.lastName = nameArr[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h4><p>与Vue2.x中watch配置功能一致</p><p class="note note-primary">两个小“坑”：监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。监视reactive定义的响应式数据中某个属性时：deep配置有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">//情况一：监视ref定义的响应式数据<br>watch(<span class="hljs-built_in">sum</span>,(newValue,oldValue)=&gt;&#123;<br>    console.log(<span class="hljs-string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;immediate:<span class="hljs-literal">true</span>&#125;)<br>​<br>//情况二：监视多个ref定义的响应式数据<br>watch([<span class="hljs-built_in">sum</span>,msg],(newValue,oldValue)=&gt;&#123;<br>    console.log(<span class="hljs-string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)<br>&#125;) <br>​<br>/* 情况三：监视reactive定义的响应式数据<br>            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！<br>            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 <br>*/<br>watch(person,(newValue,oldValue)=&gt;&#123;<br>    console.log(<span class="hljs-string">&#x27;person变化了&#x27;</span>,newValue,oldValue)<br>&#125;,&#123;immediate:<span class="hljs-literal">true</span>,deep:<span class="hljs-literal">false</span>&#125;) //此处的deep配置不再奏效<br>​<br>//情况四：监视reactive定义的响应式数据中的某个属性<br>watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:true&#125;) <br>​<br>//情况五：监视reactive定义的响应式数据中的某些属性<br>watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;immediate:true,deep:true&#125;)<br>​<br>//特殊情况<br>watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)<br>&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效<br></code></pre></td></tr></table></figure><h4 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h4><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。<br>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p><p>watchEffect有点像computed：<br>&emsp;&emsp;但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。<br>&emsp;&emsp;而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。<br>watchEffect(()=&gt;&#123;<br>    const x1 = sum.value<br>    const x2 = person.age<br>    console.log(&#x27;watchEffect配置的回调执行了&#x27;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h3><h4 id="vue2-x的生命周期"><a href="#vue2-x的生命周期" class="headerlink" title="vue2.x的生命周期"></a>vue2.x的生命周期</h4><pre><code class="hljs">(略)</code></pre><h4 id="vue3-0的生命周期"><a href="#vue3-0的生命周期" class="headerlink" title="vue3.0的生命周期"></a>vue3.0的生命周期</h4><p>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<br>&emsp;&emsp;beforeDestroy改名为 beforeUnmount<br>&emsp;&emsp;destroyed改名为 unmounted</p><p>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</p><p>beforeCreate &#x3D;&#x3D;&#x3D;&gt; setup()<br>created &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; setup()<br>beforeMount &#x3D;&#x3D;&#x3D;&gt; onBeforeMount<br>mounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; onMounted<br>beforeUpdate &#x3D;&#x3D;&#x3D;&gt; onBeforeUpdate<br>updated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; onUpdated<br>beforeUnmount &#x3D;&#x3D;&gt; onBeforeUnmount<br>unmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; onUnmounted</p><h3 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h3><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p><p>类似于vue2.x中的mixin。<a href="/2022/05/28/vue3%20Composition%20API%20%E5%92%8C%20Vue%20Mixins(1)/">Composition API 和 mixins 可移步</a><br>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p><h3 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h3><p><a href="/2021/10/09/vue3%20%E5%9F%BA%E7%A1%80-toRef/">vue3 基础-toRef 可移步</a><br>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。<br>语法：const name &#x3D; toRef(person,’name’)<br>应用: 要将响应式对象中的某个属性单独提供给外部使用时。<br>扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)</p><h2 id="其它-Composition-API"><a href="#其它-Composition-API" class="headerlink" title="其它 Composition API"></a>其它 Composition API</h2><h3 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h3><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。<br>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p><p class="note note-primary">    什么时候使用?    如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowReactive。    如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===> shallowRef。</p><h3 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h3><p>readonly: 让一个响应式数据变为只读的（深只读）。<br>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</p><p class="note note-primary">    应用场景: 不希望数据被修改时。</p><h3 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h3><p>toRaw：<br>作用：将一个由reactive生成的响应式对象转为普通对象。</p><p class="note note-primary">    使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</p><p>markRaw：<br>作用：标记一个对象，使其永远不会再成为响应式对象。</p><p class="note note-primary">    应用场景:    有些值不应被设置为响应式的，例如复杂的第三方类库等。    当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</p><h3 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h3><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p><p>实现防抖效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>    &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;keyword&quot;</span>&gt;<br>    &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br>​<br>&lt;script&gt;<br>    import &#123;ref,customRef&#125; from <span class="hljs-string">&#x27;vue&#x27;</span><br>    <span class="hljs-built_in">export</span> default &#123;<br>        name:<span class="hljs-string">&#x27;Demo&#x27;</span>,<br>        <span class="hljs-function"><span class="hljs-title">setup</span></span>()&#123;<br>            // <span class="hljs-built_in">let</span> keyword = ref(<span class="hljs-string">&#x27;hello&#x27;</span>) //使用Vue准备好的内置ref<br>            //自定义一个myRef<br>            <span class="hljs-keyword">function</span> myRef(value,delay)&#123;<br>                <span class="hljs-built_in">let</span> timer<br>                //通过customRef去实现自定义<br>                <span class="hljs-built_in">return</span> customRef((track,trigger)=&gt;&#123;<br>                    return&#123;<br>                        get()&#123;<br>                            track() //告诉Vue这个value值是需要被“追踪”的<br>                            return value<br>                        &#125;,<br>                        set(newValue)&#123;<br>                            clearTimeout(timer)<br>                            timer = setTimeout(()=&gt;&#123;<br>                                value = newValue<br>                                trigger() //告诉Vue去更新界面<br>                            &#125;,delay)<br>                        &#125;<br>                    &#125;<br>                &#125;)<br>            &#125;<br>            let keyword = myRef(&#x27;hello&#x27;,<span class="hljs-number">500</span>) //使用自定义的ref<br>            return &#123;<br>                keyword<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h3><p>作用：实现祖与后代组件间通信<br>套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据</p><p>具体写法：</p><p>祖组件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">setup</span></span>()&#123;<br>    ......<br>    <span class="hljs-built_in">let</span> car = reactive(&#123;name:<span class="hljs-string">&#x27;奔驰&#x27;</span>,price:<span class="hljs-string">&#x27;40万&#x27;</span>&#125;)<br>    provide(<span class="hljs-string">&#x27;car&#x27;</span>,car)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>后代组件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">setup(props,context)&#123;<br>    ......<br>    const car = inject(<span class="hljs-string">&#x27;car&#x27;</span>)<br>    <span class="hljs-built_in">return</span> &#123;car&#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h3><p>isRef: 检查一个值是否为一个 ref 对象<br>isReactive: 检查一个对象是否是由 reactive 创建的响应式代理<br>isReadonly: 检查一个对象是否是由 readonly 创建的只读代理<br>isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</p><h1 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/images/composition1.gif" alt="图片" title=" "></div><div class="group-image-wrap"><img src="/images/composition2.gif" alt="图片" title=" "></div></div></div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/images/composition3.gif" alt="图片" title=" "></div><div class="group-image-wrap"><img src="/images/composition4.gif" alt="图片" title=" "></div></div></div><h1 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><p>在Vue2中: 组件必须有一个根标签<br>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中<br>好处: 减少标签层级, 减小内存占用</p><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><p>什么是Teleport？—— 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- <br>    to： body html  传送位置<br>    disabled： <span class="hljs-literal">true</span> 不传送 <span class="hljs-literal">false</span> 传送<br>--&gt;<br>&lt;teleport to=<span class="hljs-string">&quot;body&quot;</span> :disabled=<span class="hljs-string">&quot;false&quot;</span>&gt;<br>&lt;div v-if=<span class="hljs-string">&quot;isShow&quot;</span> class=<span class="hljs-string">&quot;mask&quot;</span>&gt;<br>&lt;div class=<span class="hljs-string">&quot;dialog&quot;</span>&gt;<br>&lt;h3&gt;我是一个弹窗&lt;/h3&gt;<br>&lt;button @click=<span class="hljs-string">&quot;isShow = false&quot;</span>&gt;关闭弹窗&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/teleport&gt;<br></code></pre></td></tr></table></figure><p>多个 &lt; Teleport &gt; 组件可以将其内容挂载在同一个目标元素上，而顺序就是简单的顺次追加，后挂载的将排在目标元素下更后面的位置上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- index.html --&gt;<br>&lt;body&gt;<br>  &lt;div <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;&lt;/div&gt;<br>  &lt;div <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;customDom&quot;</span>&gt;&lt;/div&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>  app组件<br>  &lt;Teleport to=<span class="hljs-string">&quot;#customDom&quot;</span>&gt;<br>    &lt;p&gt;我是被 teleport 包裹的一号元素&lt;/p&gt;<br>  &lt;/Teleport&gt;<br>  &lt;Teleport to=<span class="hljs-string">&quot;#customDom&quot;</span>&gt;<br>    &lt;p&gt;我是被 teleport 包裹的二号元素&lt;/p&gt;<br>  &lt;/Teleport&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p class="note note-primary">应用：当项目中多处使用多弹窗时候，避免层级不好控制（z-index）时使用，把弹窗渲染都统一到外层一个标签内，从而方便控制。</p><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验<br>使用步骤：<br>&emsp;&emsp;异步引入组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">import &#123;defineAsyncComponent&#125; from <span class="hljs-string">&#x27;vue&#x27;</span><br>const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;))<br>使用Suspense包裹组件，并配置好default 与 fallback<br><br>&lt;template&gt;<br>&lt;div class=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>&lt;h3&gt;我是App组件&lt;/h3&gt;<br>&lt;Suspense&gt;<br>&lt;template v-slot:default&gt;<br>&lt;Child/&gt;<br>&lt;/template&gt;<br>&lt;template v-slot:fallback&gt;<br>&lt;h3&gt;加载中.....&lt;/h3&gt;<br>&lt;/template&gt;<br>&lt;/Suspense&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><p>Vue 2.x 有许多全局 API 和配置。</p><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">//注册全局组件<br>Vue.component(<span class="hljs-string">&#x27;MyButton&#x27;</span>, &#123;<br>  data: () =&gt; (&#123;<br>    count: 0<br>  &#125;),<br>  template: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br>​<br>//注册全局指令<br>Vue.directive(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  inserted: el =&gt; el.focus()<br>&#125;<br></code></pre></td></tr></table></figure><p>Vue3.0中对这些API做出了调整：</p><p>将全局的API，即：Vue.xxx调整到应用实例（app）上</p><p>2.x 全局 API（Vue）3.x 实例 API (app)<br>Vue.config.xxxx —&gt;app.config.xxxx<br>Vue.config.productionTip —&gt;移除<br>Vue.component —&gt;app.component<br>Vue.directive —&gt;app.directive<br>Vue.mixin —&gt;app.mixin<br>Vue.use —&gt;app.use<br>Vue.prototype —&gt;app.config.globalProperties</p><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><p>data选项应始终被声明为一个函数。</p><p>过度类名的更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vue2.x写法<br>.v-enter,<br>.v-leave-to &#123;<br>  opacity: 0;<br>&#125;<br>.v-leave,<br>.v-enter-to &#123;<br>  opacity: 1;<br>&#125;<br><br>Vue3.x写法<br>.v-enter-from,<br>.v-leave-to &#123;<br>  opacity: 0;<br>&#125;<br><br>.v-leave-from,<br>.v-enter-to &#123;<br>  opacity: 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes<br>移除v-on.native修饰符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">父组件中绑定事件<br><br>&lt;my-component<br>  v-on:close=<span class="hljs-string">&quot;handleComponentEvent&quot;</span><br>  v-on:click=<span class="hljs-string">&quot;handleNativeClickEvent&quot;</span><br>/&gt;<br>子组件中声明自定义事件<br><br>&lt;script&gt;<br>  <span class="hljs-built_in">export</span> default &#123;<br>    emits: [<span class="hljs-string">&#x27;close&#x27;</span>]<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>移除过滤器（filter）</p><p class="note note-primary">过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p><p>全局注册改变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">import global from <span class="hljs-string">&quot;@/utils/global&quot;</span><br><br>//在vue2中<br>vue.prototype.<span class="hljs-variable">$global</span> = global;<br>//在vue3中<br>app.config.globalProperties.<span class="hljs-variable">$global</span> = global;<br><br>//在任一vue组建中使用<br>this.<span class="hljs-variable">$global</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue 报错-“‘xxx‘ is assigned a value but never used”</title>
    <link href="/2022/03/26/vue%20%E6%8A%A5%E9%94%99-%E2%80%9C%E2%80%98xxx%E2%80%98%20is%20assigned%20a%20value%20but%20never%20used%E2%80%9D/"/>
    <url>/2022/03/26/vue%20%E6%8A%A5%E9%94%99-%E2%80%9C%E2%80%98xxx%E2%80%98%20is%20assigned%20a%20value%20but%20never%20used%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<p>当创建vue项目后，代码检测默认开启定义变量未使用即报错 ‘xxx‘ is assigned a value but never used，<br>这是eslint规则，解决方法也很简单，使用变量，第二个就是手动关闭有两种方法：</p><p>package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;eslintConfig&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;rules&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;generator-star-spacing&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>        <span class="hljs-string">&quot;no-debugger&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>        <span class="hljs-string">&quot;no-tabs&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>        <span class="hljs-string">&quot;no-unused-vars&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>        <span class="hljs-string">&quot;no-console&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>        <span class="hljs-string">&quot;no-irregular-whitespace&quot;</span>: <span class="hljs-string">&quot;off&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">特殊情况：当有.eslintrc.js 专门的配置文件时，在package.json 添加rules没有效果，需要在.eslintrc.js中添加</p><p>在错误语句后添加注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">语句 // eslint-disable-line no-unused-vars<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>报错</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue cli 的安装使用</title>
    <link href="/2022/03/23/vue%20cli/"/>
    <url>/2022/03/23/vue%20cli/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">//有老版本可以先 卸载 <br>npm uninstall vue-cli -g<br>//安装最新<br>npm install -g @vue/cli<br>//查看版本<br>vue --version<br></code></pre></td></tr></table></figure><p class="note note-primary">vue cli2与 cli3区别：默认不暴露webpack.config 文件，可以在vue.config 里配置修改，新增vue.config，public。去掉statis</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">//创建项目<br>``` bash<br>vue create 项目名<br></code></pre></td></tr></table></figure><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>&#x2F;&#x2F;一般选手动<br>Default (Vue 3) ([Vue 3] babel, eslint)(默认配置 提供babel或者eslint支持)<br>Manually select features(手动选择项目特性)</p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>&#x2F;&#x2F;回车确定后，下面配置空格选择，选择完回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Babel 主要是对es6语法转换成兼容的js （选上）<br>TypeScript 支持使用TypeScript语法来编写代码<br>Progressive Web App (PWA) Support [把网页做的更像原生app]<br>Router 支持vue路由配置插件（一般都会选择）<br>Vuex 支持vue程序状态管理模式 (一般都会选择)<br>CSS Pre-processors 支持css预处理器 （一般都会选择）<br>Linter / Formatter 支持代码风格检查和格式化 （选上）<br>Unit Testing 单元测试<br>E2E Testing E2E测试<br></code></pre></td></tr></table></figure><p>一般选择：<br><img src="/images/cli1.png" alt="图片" title=" "></p><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>Choose a version of Vue.js that you want to start the project with<br>2.x<br>3.x<br><span class="label label-primary">这里一般选择用cli来创建2.x项目，毕竟vue3项目vite创建更好(官网推荐)</span></p><h2 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h2><p>Use history mode for router? (Requires proper server setup for index fallback in production)<br>这里的意思是问你本次项目是否采用history模式，如果选择Y,需要后台配置具体看vueRouter官网解释</p><h2 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h2><p>Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default)<br>选择哪个css预处理器</p><h2 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h2><p>选择一种格式化代码方式：一般选择 第一个</p><h2 id="第九步"><a href="#第九步" class="headerlink" title="第九步"></a>第九步</h2><p>什么时候进行代码规则检测，一般会选择保存就检测，也就是Lint on Save</p><h2 id="第十步"><a href="#第十步" class="headerlink" title="第十步"></a>第十步</h2><p>Where do you prefer placing config for Babel, ESLint, etc.?<br>Babel,PostCSS,ESLint这些配置文件放哪，通常我们会选择放到独立位置 In dedicated config files，让package.json文件干净点</p><h2 id="第十一步"><a href="#第十一步" class="headerlink" title="第十一步"></a>第十一步</h2><p>Save this as a preset for future projects?<br>是否记录这次配置选择，选择之后会让你为这次配置起一个名字，这样下次可以直接快速配置选择，最后回车后就会初始化项目，可以起名common</p><p class="note note-warning">Error: spawn yarn ENOENT 如果出现以上报错为未安装yarn，全局安装yarn: npm install -g yarn<p>Error: command failed: yarn<br>如果还报错，进入到Windows环境中C:&#x2F;users&#x2F;administrator&#x2F;下找到 .vuerc文件修改<br>“packageManager”: “yarn”  —-&gt; “packageManager”: “npm”<br>意思就是依赖包管理改为npm</p><p>还报错！那就直接把.vuerc文件 删除</p></p><p><a href="/2022/07/02/vue%20%E5%9F%BA%E7%A1%80-%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/">vue2 创建项目后的基本配置</a></p>]]></content>
    
    
    <categories>
      
      <category>vue cli</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue cli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3 基础-toRef</title>
    <link href="/2021/10/09/vue3%20%E5%9F%BA%E7%A1%80-toRef/"/>
    <url>/2021/10/09/vue3%20%E5%9F%BA%E7%A1%80-toRef/</url>
    
    <content type="html"><![CDATA[<h1 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h1><p>作用： 为原响应式对象上的某个属性创建一个 ref 对象, 二者内部操作的是同一个数据值, 更新时二者是同步的。<br>语法： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">const xxx = toRef(响应式对象, <span class="hljs-string">&quot;对象属性&quot;</span>);<br></code></pre></td></tr></table></figure><p>和ref区别：<br>&emsp;&emsp;ref拷贝了一份新的数据值单独操作, 更新时相互不影响<br>&emsp;&emsp;toRef引用原响应对象数据，更新时二者是同步的<br>应用: 使用父组件传递的props数据时，要引用props的某个属性且要保持响应式连接时就很有用。</p><p>toRefFather.vue</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>  &lt;h2&gt;Father&lt;/h2&gt;<br>  &lt;p&gt;user: &#123;&#123; user &#125;&#125;&lt;/p&gt;<br>  &lt;p&gt;nameToRef: &#123;&#123; nameToRef &#125;&#125;&lt;/p&gt;<br>  &lt;p&gt;nameRef: &#123;&#123; nameRef &#125;&#125;&lt;/p&gt;<br><br>  &lt;button @click=<span class="hljs-string">&quot;update&quot;</span>&gt;更新&lt;/button&gt;<br><br>  &lt;Child :name=<span class="hljs-string">&quot;nameToRef&quot;</span> /&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span>&gt;<br>import &#123; reactive, toRef, ref &#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br>import Child from <span class="hljs-string">&quot;../components/toRefChild.vue&quot;</span>;<br><br><span class="hljs-built_in">export</span> default &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span></span>() &#123;<br><br>    const user = reactive(&#123;<br>      name: <span class="hljs-string">&#x27;温情key&#x27;</span>,<br>      age: 22,<br>    &#125;);<br><br>    const nameToRef = toRef(user, <span class="hljs-string">&quot;name&quot;</span>);<br>    const nameRef = ref(user.name);<br><br>    const update = () =&gt; &#123;<br>      user.name = user.name + <span class="hljs-string">&#x27;y&#x27;</span>;<br>      // nameToRef.value = nameToRef.value + <span class="hljs-string">&#x27;y&#x27;</span>;<br>      nameRef.value = <span class="hljs-string">&#x27;ref拷贝一份新数据，不影响原对象数据&#x27;</span>;<br>    &#125;;<br><br>    <span class="hljs-built_in">return</span> &#123;<br>      user,<br>      nameToRef,<br>      nameRef,<br>      update,<br>    &#125;;<br>  &#125;,<br><br>  components: &#123;<br>    Child,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>toRefChild.vue</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>  &lt;h2&gt;Child&lt;/h2&gt;<br>  &lt;h3&gt;nameToRef: &#123;&#123; name &#125;&#125;&lt;/h3&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span>&gt;<br>import &#123; computed, defineComponent, Ref, toRef &#125; from <span class="hljs-string">&quot;vue&quot;</span>;<br><br>const component = defineComponent(&#123;<br>  props: &#123;<br>    name: &#123;<br>      <span class="hljs-built_in">type</span>: String,<br>      require: <span class="hljs-literal">true</span>,<br>    &#125;,<br>  &#125;,<br><br>  setup(props, context) &#123;<br>   <br>    <span class="hljs-built_in">return</span> &#123;<br>      <br>    &#125;;<br>  &#125;,<br>&#125;);<br><br><span class="hljs-built_in">export</span> default component;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p class="note note-primary">    用toRef 单独获取响应式对象中属性，保持响应式，使用或者改变一同改变。    ref取响应式对象中属性，会拷贝新建一个完全独立的响应式数据，改变不相互影响。</p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue 生命周期咋个事.md</title>
    <link href="/2021/06/01/vue%20%E4%B8%80%E5%9B%BE%E4%BA%86%E8%A7%A3vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2021/06/01/vue%20%E4%B8%80%E5%9B%BE%E4%BA%86%E8%A7%A3vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/vue1.jpg" alt="图片" title=" "></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex 模块化开发</title>
    <link href="/2021/03/12/vuex%20%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <url>/2021/03/12/vuex%20%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="首先来简单介绍一下vuex"><a href="#首先来简单介绍一下vuex" class="headerlink" title="首先来简单介绍一下vuex"></a>首先来简单介绍一下vuex</h2><p>Vuex 是一个用于状态管理的库，它是为 Vue.js 应用程序开发的，旨在帮助管理数据的流动和共享。</p><p>状态（State）：单一状态树（State Tree）是存储整个应用程序状态的地方。状态是保存在 Vuex 中的集中式公共数据源，可以通过 this.$store.state 访问（当然你得挂载全局vue2中：Vue.prototype.axios &#x3D; axios; vue3就用app.config.globalProperties.$axios &#x3D; axios;）。它通常被看作是应用程序的唯一数据源。</p><p>Getter：Getter 允许从存储在 Vuex 中的状态派生出新的状态。类似于 Vue 组件中的计算属性，Getter 可以对状态进行处理和计算，并将结果暴露给其他组件使用。</p><p>Mutation：Mutation 是修改状态的唯一方式。Mutation 必须是同步函数，用于更改状态并跟踪状态变化。它们在提交时需要调用 commit 方法，并接收一个参数来传递数据载荷（Payload）。只有 Mutation 才能修改状态，这样确保了状态的变更可追踪和可维护性。</p><p>Action：Action 用于处理异步操作或包含多个 Mutation 的复杂操作。Action 可以包含任意异步操作，例如从服务器获取数据后提交 Mutation 来更新状态。Action 在组件中通过调用 dispatch 方法来触发，可以接收一个 Promise，以便异步操作完成后再提交 Mutation。</p><p>Module：Module 允许将 Vuex 分割成单个模块。每个模块拥有自己的状态、Getter、Mutation 和 Action，可以嵌套引用其他模块。这样组织代码可以更好地扩展和维护，并且可以在不同模块之间共享状态。</p><p class="note note-primary">实现全局状态的集中管理，使不同组件之间能够方便地共享和更新状态。（常用于权限控制，用户状态等）</p><h2 id="组合式开发"><a href="#组合式开发" class="headerlink" title="组合式开发"></a>组合式开发</h2><p>首先创建一个store文件夹，创建一个index.js文件，引入Vue和Vuex，如果需要模块化开发就在index.js文件夹中引入创建的另外store仓库js文件，然后通过modules 把他们两个合并起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">// store/index.js<br>import Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br>//引入Vuex<br>import Vuex from <span class="hljs-string">&#x27;vuex&#x27;</span><br>import countOptions from <span class="hljs-string">&#x27;./count&#x27;</span><br>import personOptions from <span class="hljs-string">&#x27;./person&#x27;</span><br>//应用Vuex插件<br>Vue.use(Vuex)<br> <br>//创建并暴露store<br><span class="hljs-built_in">export</span> default new Vuex.Store(&#123;<br>modules:&#123;<br>countAbout:countOptions,<br>personAbout:personOptions<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上代码中 .&#x2F;count 属于count仓库。<br>count仓库中有五大属性 分为 actions，mutations，state，getters，modules</p><p class="note note-primary">namespaced:true， 这个配置是独立命名空间，如果false将都处于同一命名空间，模块化就只是写法上分开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">//求和相关的配置<br><span class="hljs-built_in">export</span> default &#123;<br>namespaced:<span class="hljs-literal">true</span>,<br>actions:&#123;<br>jiaOdd(context,value)&#123;<br>console.log(<span class="hljs-string">&#x27;actions中的jiaOdd被调用了&#x27;</span>)<br><span class="hljs-keyword">if</span>(context.state.sum % 2)&#123;<br>context.commit(<span class="hljs-string">&#x27;JIA&#x27;</span>,value)<br>&#125;<br>&#125;,<br>jiaWait(context,value)&#123;<br>console.log(<span class="hljs-string">&#x27;actions中的jiaWait被调用了&#x27;</span>)<br>setTimeout(()=&gt;&#123;<br>context.commit(&#x27;JIA&#x27;,value)<br>&#125;,<span class="hljs-number">500</span>)<br>&#125;<br>&#125;,<br>mutations:&#123;<br>JIA(state,value)&#123;<br>console.log(&#x27;mutations中的JIA被调用了&#x27;)<br>state.sum += value<br>&#125;,<br>JIAN(state,value)&#123;<br>console.log(&#x27;mutations中的JIAN被调用了&#x27;)<br>state.sum -= value<br>&#125;,<br>&#125;,<br>state:&#123;<br>sum:<span class="hljs-number">0</span>, //当前的和<br>school:&#x27;不知名&#x27;,<br>subject:&#x27;前端&#x27;,<br>&#125;,<br>getters:&#123;<br>bigSum(state)&#123;<br>return state.sum*<span class="hljs-number">10</span><br>&#125;<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="vue模块化就完成了，下面来看一下使用"><a href="#vue模块化就完成了，下面来看一下使用" class="headerlink" title="vue模块化就完成了，下面来看一下使用"></a>vue模块化就完成了，下面来看一下使用</h2><p>方法1：vuex的优化函数 使用map…</p><p>首先引入 四种方法,import {mapState,mapGetters,mapMutations,mapActions} from ‘vuex’<br>在计算属性computed中可以展开 mapState, mapGetters 来获取数据<br>在methods 中可以展开 mapMutations mapActions 来派发actions方法,或者直接修改mutations中的数据<br>…mapState(‘countAbout’,[‘sum’,’school’,’subject’]), 第一个参数意思是从模块化modules中的countAbout 获取数据,第二个参数是 countAbout文件中获取state数据,是一个数组<br>method中 …mapMutations(‘countAbout’,{increment:’JIA’,decrement:’JIAN’}),<br>第一个参数是模块化名字,第二个参数是键值对形式,键是ui页面中触发的方法,第二个参数是mutilation中对应的的方法 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;template&gt;<br>&lt;div&gt;<br>&lt;h1&gt;当前求和为：&#123;&#123;<span class="hljs-built_in">sum</span>&#125;&#125;&lt;/h1&gt;<br>&lt;h3&gt;当前求和放大10倍为：&#123;&#123;bigSum&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;我在&#123;&#123;school&#125;&#125;，学习&#123;&#123;subject&#125;&#125;&lt;/h3&gt;<br>&lt;h3 style=<span class="hljs-string">&quot;color:red&quot;</span>&gt;Person组件的总人数是：&#123;&#123;personList.length&#125;&#125;&lt;/h3&gt;<br>&lt;<span class="hljs-keyword">select</span> v-model.number=<span class="hljs-string">&quot;n&quot;</span>&gt;<br>&lt;option value=<span class="hljs-string">&quot;1&quot;</span>&gt;1&lt;/option&gt;<br>&lt;option value=<span class="hljs-string">&quot;2&quot;</span>&gt;2&lt;/option&gt;<br>&lt;option value=<span class="hljs-string">&quot;3&quot;</span>&gt;3&lt;/option&gt;<br>&lt;/select&gt;<br>&lt;button @click=<span class="hljs-string">&quot;increment(n)&quot;</span>&gt;+&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;decrement(n)&quot;</span>&gt;-&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;incrementOdd(n)&quot;</span>&gt;当前求和为奇数再加&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;incrementWait(n)&quot;</span>&gt;等一等再加&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br> <br>&lt;script&gt;<br>import &#123;mapState,mapGetters,mapMutations,mapActions&#125; from <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-built_in">export</span> default &#123;<br>name:<span class="hljs-string">&#x27;Count&#x27;</span>,<br><span class="hljs-function"><span class="hljs-title">data</span></span>() &#123;<br><span class="hljs-built_in">return</span> &#123;<br>n:1, //用户选择的数字<br>&#125;<br>&#125;,<br>computed:&#123;<br>//借助mapState生成计算属性，从state中读取数据。（数组写法）<br>...mapState(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>]),<br>...mapState(<span class="hljs-string">&#x27;personAbout&#x27;</span>,[<span class="hljs-string">&#x27;personList&#x27;</span>]),<br>//借助mapGetters生成计算属性，从getters中读取数据。（数组写法）<br>...mapGetters(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br>&#125;,<br>methods: &#123;<br>//借助mapMutations生成对应的方法，方法中会调用commit去联系mutations(对象写法)<br>...mapMutations(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;increment:<span class="hljs-string">&#x27;JIA&#x27;</span>,decrement:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br>//借助mapActions生成对应的方法，方法中会调用dispatch去联系actions(对象写法)<br>...mapActions(<span class="hljs-string">&#x27;countAbout&#x27;</span>,&#123;incrementOdd:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,incrementWait:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">mounted</span></span>() &#123;<br>console.log(this.<span class="hljs-variable">$store</span>)<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br> <br>&lt;style lang=<span class="hljs-string">&quot;css&quot;</span>&gt;<br>button&#123;<br>margin-left: 5px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>方法2：通过挂载方式获取store来使用</p><p>首先 需要在入口文件中引入store并把挂载到vm身上<br>然后就可以在页面中通过  this.$store.state.personAbout 获取personAbout<br>模块中的数据<br>通过this.$store.getters[‘personAbout&#x2F;firstPersonName’]获取仓库中的计算属性数据<br>通过this.$store.commit(‘personAbout&#x2F;ADD_PERSON’,personObj)<br>触发 personAbout仓库中mutions的方法 commit 是直接触发mutions方法中的函数,一般不需要异步操作就可以直接使用这种方式,<br>通过this.$store.dispatch(‘personAbout&#x2F;addPersonWang’,personObj)<br>触发 action中的异步方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs bash">//main.js<br>//引入Vue<br>import Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br>//引入App<br>import App from <span class="hljs-string">&#x27;./App.vue&#x27;</span><br>//引入插件<br>import vueResource from <span class="hljs-string">&#x27;vue-resource&#x27;</span><br>//引入store<br>import store from <span class="hljs-string">&#x27;./store&#x27;</span><br> <br>//关闭Vue的生产提示<br>Vue.config.productionTip = <span class="hljs-literal">false</span><br>//使用插件<br>Vue.use(vueResource)<br> <br>//创建vm<br>new Vue(&#123;<br>el:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>render: h =&gt; h(App),<br>store,<br><span class="hljs-function"><span class="hljs-title">beforeCreate</span></span>() &#123;<br>Vue.prototype.<span class="hljs-variable">$bus</span> = this<br>&#125;<br>&#125;)<br>``` bash<br>&lt;!-- person.vue --&gt;<br>&lt;template&gt;<br>&lt;div&gt;<br>&lt;h1&gt;人员列表&lt;/h1&gt;<br>&lt;h3 style=<span class="hljs-string">&quot;color:red&quot;</span>&gt;Count组件求和为：&#123;&#123;<span class="hljs-built_in">sum</span>&#125;&#125;&lt;/h3&gt;<br>&lt;h3&gt;列表中第一个人的名字是：&#123;&#123;firstPersonName&#125;&#125;&lt;/h3&gt;<br>&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> placeholder=<span class="hljs-string">&quot;请输入名字&quot;</span> v-model=<span class="hljs-string">&quot;name&quot;</span>&gt;<br>&lt;button @click=<span class="hljs-string">&quot;add&quot;</span>&gt;添加&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;addWang&quot;</span>&gt;添加一个姓王的人&lt;/button&gt;<br>&lt;button @click=<span class="hljs-string">&quot;addPersonServer&quot;</span>&gt;添加一个人，名字随机&lt;/button&gt;<br>&lt;ul&gt;<br>&lt;li v-for=<span class="hljs-string">&quot;p in personList&quot;</span> :key=<span class="hljs-string">&quot;p.id&quot;</span>&gt;&#123;&#123;p.name&#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br> <br>&lt;script&gt;<br>import &#123;nanoid&#125; from <span class="hljs-string">&#x27;nanoid&#x27;</span><br><span class="hljs-built_in">export</span> default &#123;<br>name:<span class="hljs-string">&#x27;Person&#x27;</span>,<br><span class="hljs-function"><span class="hljs-title">data</span></span>() &#123;<br><span class="hljs-built_in">return</span> &#123;<br>name:<span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br>&#125;,<br>computed:&#123;<br><span class="hljs-function"><span class="hljs-title">personList</span></span>()&#123;<br><span class="hljs-built_in">return</span> this.<span class="hljs-variable">$store</span>.state.personAbout.personList<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">sum</span></span>()&#123;<br><span class="hljs-built_in">return</span> this.<span class="hljs-variable">$store</span>.state.countAbout.<span class="hljs-built_in">sum</span><br>&#125;,<br><span class="hljs-function"><span class="hljs-title">firstPersonName</span></span>()&#123;<br><span class="hljs-built_in">return</span> this.<span class="hljs-variable">$store</span>.getters[<span class="hljs-string">&#x27;personAbout/firstPersonName&#x27;</span>]<br>&#125;<br>&#125;,<br>methods: &#123;<br><span class="hljs-function"><span class="hljs-title">add</span></span>()&#123;<br>const personObj = &#123;<span class="hljs-built_in">id</span>:nanoid(),name:this.name&#125;<br>this.<span class="hljs-variable">$store</span>.commit(<span class="hljs-string">&#x27;personAbout/ADD_PERSON&#x27;</span>,personObj)<br>this.name = <span class="hljs-string">&#x27;&#x27;</span><br>&#125;,<br><span class="hljs-function"><span class="hljs-title">addWang</span></span>()&#123;<br>const personObj = &#123;<span class="hljs-built_in">id</span>:nanoid(),name:this.name&#125;<br>this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&#x27;personAbout/addPersonWang&#x27;</span>,personObj)<br>this.name = <span class="hljs-string">&#x27;&#x27;</span><br>&#125;,<br><span class="hljs-function"><span class="hljs-title">addPersonServer</span></span>()&#123;<br>this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&#x27;personAbout/addPersonServer&#x27;</span>)<br>&#125;<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash">//person.js<br>//人员管理相关的配置<br>import axios from <span class="hljs-string">&#x27;axios&#x27;</span><br>import &#123; nanoid &#125; from <span class="hljs-string">&#x27;nanoid&#x27;</span><br><span class="hljs-built_in">export</span> default &#123;<br>namespaced:<span class="hljs-literal">true</span>,<br>actions:&#123;<br>addPersonWang(context,value)&#123;<br><span class="hljs-keyword">if</span>(value.name.indexOf(<span class="hljs-string">&#x27;王&#x27;</span>) === 0)&#123;<br>context.commit(<span class="hljs-string">&#x27;ADD_PERSON&#x27;</span>,value)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>alert(<span class="hljs-string">&#x27;添加的人必须姓王！&#x27;</span>)<br>&#125;<br>&#125;,<br>addPersonServer(context)&#123;<br>axios.get(<span class="hljs-string">&#x27;https://api.uixsj.cn/hitokoto/get?type=social&#x27;</span>).<span class="hljs-keyword">then</span>(<br>response =&gt; &#123;<br>context.commit(<span class="hljs-string">&#x27;ADD_PERSON&#x27;</span>,&#123;<span class="hljs-built_in">id</span>:nanoid(),name:response.data&#125;)<br>&#125;,<br>error =&gt; &#123;<br>alert(error.message)<br>&#125;<br>)<br>&#125;<br>&#125;,<br>mutations:&#123;<br>ADD_PERSON(state,value)&#123;<br>console.log(<span class="hljs-string">&#x27;mutations中的ADD_PERSON被调用了&#x27;</span>)<br>state.personList.unshift(value)<br>&#125;<br>&#125;,<br>state:&#123;<br>personList:[<br>&#123;<span class="hljs-built_in">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,name:<span class="hljs-string">&#x27;张三&#x27;</span>&#125;<br>]<br>&#125;,<br>getters:&#123;<br>firstPersonName(state)&#123;<br><span class="hljs-built_in">return</span> state.personList[0].name<br>&#125;<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vuex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vuex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html 基础-空格符号</title>
    <link href="/2021/02/27/html%20%E5%9F%BA%E7%A1%80-%E7%A9%BA%E6%A0%BC/"/>
    <url>/2021/02/27/html%20%E5%9F%BA%E7%A1%80-%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="html中的空格符号-nbsp-ensp-emsp"><a href="#html中的空格符号-nbsp-ensp-emsp" class="headerlink" title="html中的空格符号  nbsp; ensp; emsp;"></a>html中的空格符号  nbsp; ensp; emsp;</h1><h2 id="不同空格符合的区别"><a href="#不同空格符合的区别" class="headerlink" title="不同空格符合的区别"></a>不同空格符合的区别</h2><p>我是开始&nbsp;半角的不断行的空白格（推荐使用）<br>我是开始&ensp;半角的空格<br>我是开始&emsp;全角的空格</p><p>&amp;nbsp; 这是我们使用最多的空格，也就是按下space键产生的空格。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加。该空格占据宽度受字体影响明显而强烈。在inline-block布局中会搞些小破坏，在两端对齐布局中又是不可少的元素。</p><p>&amp;ensp; 此空格有个相当稳健的特性，就是其占据的宽度正好是1&#x2F;2个中文宽度，而且基本上不受字体影响。<br>&amp;emsp; 此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于&amp;ensp;和&amp;emsp;在一些中文排版对齐方面可以使用，如下html代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;ul&gt;<br>    &lt;li class=<span class="hljs-string">&quot;li&quot;</span>&gt;姓&amp;emsp;&amp;emsp;名：&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;&lt;/li&gt;<br>    &lt;li class=<span class="hljs-string">&quot;li&quot;</span>&gt;手&amp;ensp;机&amp;ensp;号：&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;&lt;/li&gt;<br>    &lt;li class=<span class="hljs-string">&quot;li&quot;</span>&gt;电子邮箱：&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><ul>    <li class="li">姓&emsp;&emsp;名：<input type="text" /></li>    <li class="li">手&ensp;机&ensp;号：<input type="text" /></li>    <li class="li">电子邮箱：<input type="text" /></li></ul><p class="note note-warning">注意：上面的空白字符中文对齐方法在IE6下不能完全兼容。（可以使用css样式来调整，不过谁还用IE！）</p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
      <category>空格</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>script 基础-循环</title>
    <link href="/2020/01/01/script%20%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF/"/>
    <url>/2020/01/01/script%20%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript数组循环"><a href="#JavaScript数组循环" class="headerlink" title="JavaScript数组循环"></a>JavaScript数组循环</h1><p>利用Javascript map(),reduce()和filter()数组方法可以帮助您编写更加声明性、流畅的风格代码。</p><p>而不是积累起来for循环和嵌套来处理列表和集合中的数据，您可以利用这些方法更好地将逻辑组织成功能的构建块，然后将它们链接起来以创建更可读和更易于理解的实现。</p><p>ES6还为我们提供了一些更好的数组方法，比如.find,.findIndex,.of和for..of循环！</p><h2 id="数组循环"><a href="#数组循环" class="headerlink" title="数组循环"></a>数组循环</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officers = [<br>    &#123; <span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&#x27;Captain Piett&#x27;</span> &#125;,<br>    &#123; <span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&#x27;General Veers&#x27;</span> &#125;,<br>    &#123; <span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&#x27;Admiral Ozzel&#x27;</span> &#125;,<br>    &#123; <span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&#x27;Commander Jerjerrod&#x27;</span> &#125;<br>];<br>// What you need<br>// [20, 24, 56, 88]<br></code></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>使用率最高，也是最基本的一种遍历方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officersIds = [];<br><span class="hljs-keyword">for</span>(var i=0,len=officers.length;i&lt;len; i++)&#123;<br>    officersIds.push(officers[i].<span class="hljs-built_in">id</span>);<br>&#125;<br>console.log(officersIds); // [20,24,56,88]<br></code></pre></td></tr></table></figure><h2 id="forEach循环"><a href="#forEach循环" class="headerlink" title="forEach循环"></a>forEach循环</h2><p>forEach中传入要执行的回调函数，函数有三个参数。第一个参数为数组元素(必选)，第二个参数为数组元素索引值(可选)，第三个参数为数组本身(可选)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officersIds = [];<br>officers.forEach(<span class="hljs-keyword">function</span> (officer,index,array) &#123;<br>    console.log(index); //0,1,2,3,<br>    console.log(officer); //&#123;<span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&quot;Captain Piett&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&quot;General Veers&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&quot;Admiral Ozzel&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&quot;Commander Jerjerrod&quot;</span>&#125;<br>    officersIds.push(officer.id);<br>&#125;);<br>console.log(officersIds); //[20,24,56,88]<br></code></pre></td></tr></table></figure><h2 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for in循环"></a>for in循环</h2><p>for…in循环可用于循环对象和数组,推荐用于循环对象,可以用来遍历JSON</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officersIds = [];<br><span class="hljs-keyword">for</span>(var key <span class="hljs-keyword">in</span> officers)&#123;<br>    console.log(key); // 0 1 2 3 返回数组索引<br>    console.log(officers[key]); //&#123;<span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&quot;Captain Piett&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&quot;General Veers&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&quot;Admiral Ozzel&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&quot;Commander Jerjerrod&quot;</span>&#125;<br>    officersIds.push(officers[key].<span class="hljs-built_in">id</span>);<br>&#125;<br>console.log(officersIds); //[20,24,56,88]<br></code></pre></td></tr></table></figure><h2 id="for-of循环"><a href="#for-of循环" class="headerlink" title="for of循环"></a>for of循环</h2><p>可循环数组和对象，推荐用于遍历数组。</p><p>for…of提供了三个新方法：</p><p>key()是对键名的遍历；<br>value()是对键值的遍历；<br>entries()是对键值对的遍历；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> arr = [<span class="hljs-string">&#x27;科大讯飞&#x27;</span>, <span class="hljs-string">&#x27;政法BG&#x27;</span>, <span class="hljs-string">&#x27;前端开发&#x27;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item of arr) &#123;  <br>  console.log(item); //  科大讯飞  政法BG  前端开发<br>&#125;<br>// 输出数组索引<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> item of arr.keys()) &#123;  <br>  console.log(item);  // 0 1 2<br>&#125;<br>// 输出内容和索引<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> [item, val] of arr.entries()) &#123;  <br>  console.log(item + <span class="hljs-string">&#x27;:&#x27;</span> + val); //  0:科大讯飞  1：政法BG  2：前端开发<br>&#125;<br><br>var officersIds = [];<br><span class="hljs-keyword">for</span> (var item of officers) &#123;<br>    console.log(item); //&#123;<span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&quot;Captain Piett&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&quot;General Veers&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&quot;Admiral Ozzel&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&quot;Commander Jerjerrod&quot;</span>&#125;<br>    officersIds.push(item.id); <br>&#125;<br>console.log(officersIds); // [20,24,56,88]<br>// 输出数组索引<br><span class="hljs-keyword">for</span>(var item of officers.keys())&#123;<br>    console.log(item); // 0 1 2 3<br>&#125;<br>// 输出内容和索引<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> [item, val] of officers.entries()) &#123;<br>    console.log(item) // 0 1 2 3 输出数组索引<br>    console.log(val);//&#123;<span class="hljs-built_in">id</span>: 20, name: <span class="hljs-string">&quot;Captain Piett&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 24, name: <span class="hljs-string">&quot;General Veers&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 56, name: <span class="hljs-string">&quot;Admiral Ozzel&quot;</span>&#125;,&#123;<span class="hljs-built_in">id</span>: 88, name: <span class="hljs-string">&quot;Commander Jerjerrod&quot;</span>&#125;<br>    console.log(item + <span class="hljs-string">&#x27;:&#x27;</span> + val); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="map循环"><a href="#map循环" class="headerlink" title="map循环"></a>map循环</h2><p>map() 会返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。<br>map() 方法按照原始数组元素顺序依次处理元素。</p><p>map 不修改调用它的原数组本身。</p><p>map()中传入要执行的回调函数，函数有三个参数。第一个参数为数组元素(必选)，第二个参数为数组元素索引值(可选)，第三个参数为数组本身(可选)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">var arr = [<br>    &#123;name:<span class="hljs-string">&#x27;a&#x27;</span>,age:<span class="hljs-string">&#x27;18&#x27;</span>&#125;,<br>    &#123;name:<span class="hljs-string">&#x27;b&#x27;</span>,age:<span class="hljs-string">&#x27;19&#x27;</span>&#125;,<br>    &#123;name:<span class="hljs-string">&#x27;c&#x27;</span>,age:<span class="hljs-string">&#x27;20&#x27;</span>&#125;<br>];<br>arr.map(<span class="hljs-keyword">function</span>(item,index) &#123;<br>    <span class="hljs-keyword">if</span>(item.name == <span class="hljs-string">&#x27;b&#x27;</span>) &#123;<br>        console.log(index)  // 1<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>数组加一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">var officersIds = officers.map(<span class="hljs-keyword">function</span> (officer) &#123;<br>    <span class="hljs-built_in">return</span> officer.id<br>&#125;);<br>console.log(officersIds); //[20,24,56,88]<br></code></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">array.reduce(<span class="hljs-keyword">function</span> callback(accumulator, currentValue, currentIndex, array)&#123;<br><br>&#125;[, initialValue])<br><br>var peoples = [<br>  &#123;<br>    <span class="hljs-built_in">id</span>: 10,<br>    name: <span class="hljs-string">&quot;Poe Dameron&quot;</span>,<br>    years: 14,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-built_in">id</span>: 2,<br>    name: <span class="hljs-string">&quot;Temmin &#x27;Snap&#x27; Wexley&quot;</span>,<br>    years: 30,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-built_in">id</span>: 41,<br>    name: <span class="hljs-string">&quot;Tallissan Lintra&quot;</span>,<br>    years: 16,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-built_in">id</span>: 99,<br>    name: <span class="hljs-string">&quot;Ello Asty&quot;</span>,<br>    years: 22,<br>  &#125;<br>];<br></code></pre></td></tr></table></figure><h3 id="输出他们的年龄总数"><a href="#输出他们的年龄总数" class="headerlink" title="输出他们的年龄总数"></a>输出他们的年龄总数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var totalYears = peoples.reduce(<span class="hljs-keyword">function</span> (total, people) &#123;<br>    console.log(total);<br>    console.log(people);<br>    <span class="hljs-built_in">return</span> total + people.years;<br>&#125;, 0);<br>// const totalYears = people.reduce((acc, people) =&gt; acc + people.years, <span class="hljs-number">0</span>);<br>console.log(totalYears); //<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><h3 id="求年龄最大的那个人"><a href="#求年龄最大的那个人" class="headerlink" title="求年龄最大的那个人"></a>求年龄最大的那个人</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var oldest = peoples.reduce(<span class="hljs-keyword">function</span> (oldest, people) &#123;<br>    <span class="hljs-built_in">return</span> (oldest.years || 0) &gt; people.years ? oldest : people;<br>&#125;, &#123;&#125;);<br>console.log(oldest); //&#123;<span class="hljs-built_in">id</span>: 2, name: <span class="hljs-string">&quot;Temmin &#x27;Snap&#x27; Wexley&quot;</span>, years: 30&#125;<br>console.log(oldest.years); //82<br></code></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">array.filter(<span class="hljs-keyword">function</span>(currentValue,index,arr)&#123;<br><br>&#125;, thisValue)<br></code></pre></td></tr></table></figure><p>演示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">var designer = peoples.filter(<span class="hljs-keyword">function</span> (people) &#123;<br>    <span class="hljs-built_in">return</span> people.job === <span class="hljs-string">&quot;designer&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">var totalScore = peoples<br>    .filter(<span class="hljs-keyword">function</span> (person) &#123;<br>        <span class="hljs-built_in">return</span> person.isForceUser;<br>    &#125;)<br>    .map(<span class="hljs-keyword">function</span> (choose) &#123;<br>        <span class="hljs-built_in">return</span> choose.mathScore + choose.englishScore;<br>    &#125;)<br>    .reduce(<span class="hljs-keyword">function</span> (total, score) &#123;<br>        <span class="hljs-built_in">return</span> total + score;<br>    &#125;, 0);<br></code></pre></td></tr></table></figure><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">var divs = document.querySelectorAll(<span class="hljs-string">&#x27;div.pane&#x27;</span>);  <br>var text = Array.from(divs, (d) =&gt; d.textContent);  <br>console.log(<span class="hljs-string">&quot;div text:&quot;</span>, text);<br><br>// Old, ES5 way to get array from arguments<br><span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;  <br>  var args = [].slice.call(arguments);<br>  //...<br>&#125;<br><br>// Using ES6 Array.from<br><span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;  <br>  var args = Array.from(arguments);<br>  //..<br>&#125;<br><br>var filled = Array.from([1,,2,,3], (n) =&gt; n || 0);  <br>console.log(<span class="hljs-string">&quot;filled:&quot;</span>, filled);  <br>// =\&gt; [1,0,2,0,3]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>循环</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
